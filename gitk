#!/bin/sh
# Tcl ignores the next line -*- tcl -*- \
exec wish "$0" -- "$@"

# Copyright (C) 2005-2006 Paul Mackerras.  All rights reserved.
# This program is free software; it may be used, copied, modified
# and distributed under the terms of the GNU General Public Licence,
# either version 2, or (at your option) any later version.

package require Tcl 8.4

proc gitdir {} {
    global env
    if {[info exists env(GIT_DIR)]} {
	return $env(GIT_DIR)
    } else {
	return ".git"
    }
}

# Stuff needed by both the main thread and the layout thread
set commonstuff {

    # A simple scheduler for compute-intensive stuff.
    # The aim is to make sure that event handlers for GUI actions can
    # run at least every 50-100 ms.  Unfortunately fileevent handlers are
    # run before X event handlers, so reading from a fast source can
    # make the GUI completely unresponsive.
    set runq {}

    proc run args {
	global isonrunq runq

	set script $args
	if {[info exists isonrunq($script)]} return
	if {$runq eq {}} {
	    after idle dorunq
	}
	lappend runq [list {} $script]
	set isonrunq($script) 1
    }

    proc filerun {fd script} {
	fileevent $fd readable [list filereadable $fd $script]
    }

    proc filereadable {fd script} {
	global runq

	fileevent $fd readable {}
	if {$runq eq {}} {
	    after idle dorunq
	}
	lappend runq [list $fd $script]
    }

    proc dorunq {} {
	global isonrunq runq

	set tstart [clock clicks -milliseconds]
	set t0 $tstart
	while {$runq ne {}} {
	    set fd [lindex $runq 0 0]
	    set script [lindex $runq 0 1]
	    set repeat [eval $script]
	    set t1 [clock clicks -milliseconds]
	    set t [expr {$t1 - $t0}]
	    set runq [lrange $runq 1 end]
	    if {$repeat ne {} && $repeat} {
		if {$fd eq {} || $repeat == 2} {
		    # script returns 1 if it wants to be readded
		    # file readers return 2 if they could do more straight away
		    lappend runq [list $fd $script]
		} else {
		    fileevent $fd readable [list filereadable $fd $script]
		}
	    } elseif {$fd eq {}} {
		unset isonrunq($script)
	    }
	    set t0 $t1
	    if {$t1 - $tstart >= 80} break
	}
	if {$runq ne {}} {
	    after idle dorunq
	}
    }

    # Each row is given a token, which is a series of integers,
    # in such a manner that tokens increase with row number, but don't
    # have to be reassigned when rows are inserted.

    # Compare two tokens, return -1, 0 or 1
    proc tokencmp {t1 t2 {i 0}} {
	set comp 0
	set t1len [llength $t1]
	set t2len [llength $t2]
	for {} {$i < $t1len && $i < $t2len} {incr i} {
	    if {[lindex $t1 $i] < [lindex $t2 $i]} {
		set comp -1
		break
	    }
	    if {[lindex $t1 $i] > [lindex $t2 $i]} {
		set comp 1
		break
	    }
	}
	if {$comp == 0} {
	    if {$t1len < $t2len} {
		set comp -1
	    } elseif {$t1len > $t2len} {
		set comp 1
	    }
	}
	return $comp
    }

    # This function finds the row number for an id by getting its token
    # and doing a binary search on the list of tokens.
    proc rowofcommit {view id} {
	%ifnotthread% global ctok$view vtokenlist

	if {![%tsvexists% ctok$view $id]} {
	    return {}
	}
	set tok [%tsvget% ctok$view $id]
	set tok0 [lindex $tok 0]
	set toklen [llength $tok]
	set llen [%tsvllength% vtokenlist $view]
	set lo 0
	set hi $llen
	while {$lo < $hi} {
	    set mid [expr {($lo + $hi) / 2}]
	    set mt [%tsvlindex% vtokenlist $view $mid]
	    set mt0 [lindex $mt 0]
	    if {$tok0 < $mt0} {
		set hi $mid
	    } elseif {$tok0 > $mt0} {
		set lo [expr {$mid + 1}]
	    } else {
		set mclen [llength $mt]
		if {$toklen == 1} {
		    if {[llength $mt] == 1} {
			return $mid
		    }
		    set comp -1
		} else {
		    set comp [tokencmp $tok $mt 1]
		    if {$comp == 0} {
			return $mid
		    }
		}
		if {$comp < 0} {
		    set hi $mid
		} else {
		    set lo [expr {$mid + 1}]
		}
	    }
	}
	puts "oops token {$tok} not in list"
	return {}
    }

    proc shortids {ids} {
	set res {}
	foreach id $ids {
	    if {[llength $id] > 1} {
		lappend res [shortids $id]
	    } elseif {[regexp {^[0-9a-f]{40}$} $id]} {
		lappend res [string range $id 0 7]
	    } else {
		lappend res $id
	    }
	}
	return $res
    }
}

# The following procedures run in the thread that reads the git rev-list
# output and lays out the graph.
set lthreadstuff {
    proc save_view {} {
	global curview viewdata rowidlist rowoffsets idinlist
	global rowlaidout rowoptim lnumcommits

	set viewdata($curview) \
	    [list $rowidlist $rowoffsets [array get idinlist] \
		 $rowlaidout $rowoptim $lnumcommits]
    }

    proc restore_view {view} {
	global viewdata rowidlist rowoffsets idinlist
	global rowlaidout rowoptim lnumcommits

	set rowidlist [lindex $viewdata($view) 0]
	set rowoffsets [lindex $viewdata($view) 1]
	array set idinlist [lindex $viewdata($view) 2]
	set rowlaidout [lindex $viewdata($view) 3]
	set rowoptim [lindex $viewdata($view) 4]
	set lnumcommits [lindex $viewdata($view) 5]
    }

    proc start_layout {view} {
	global curview viewdata

	if {[info exists curview]} {
	    if {$curview == $view} {
		stop_rev_list
		catch {tsv::unset children$view}
		catch {tsv::unset parents$view}
		catch {tsv::unset ctok$view}
		catch {unset viewdata($view)}
	    } else {
		save_view
	    }
	}
	set curview $view
	initlayout
	start_rev_list $view
    }

    proc layout_finished {} {
	global rowoffsets idinlist

	set rowoffsets {}
	catch {unset idinlist}
    }

    proc switch_view {view} {
	global curview viewdata lnumcommits commitidx

	if {[info exists curview]} {
	    if {$view == $curview} return
	    save_view
	}
	set curview $view
	if {[info exists viewdata($view)]} {
	    restore_view $view
	} else {
	    initlayout
	}
	if {$lnumcommits < $commitidx($view)} {
	    run chewcommits
	}
    }

    # Start off a git rev-list process and arrange to read its output
    proc start_rev_list {view} {
	global startms misordered curview
	global commfd leftover tclencoding datemode
	global commitidx reorderbuf
	global lviewgen
	global vnexttoken disporder vtokenlist vcmitlisted

	set startms($view) [clock clicks -milliseconds]
	set disporder($view) {}
	%iflthread% tsv::set disporder $view {}
	set vcmitlisted($view) {}
	%iflthread% tsv::set vcmitlisted $view {}
	set vtokenlist($view) {}
	%iflthread% tsv::set vtokenlist $view {}
	set vnexttoken($view) 1
	set commitidx($view) 0
	set reorderbuf($view) {}
	set misordered($view) 0
	if {![info exists lviewgen($view)]} {
	    set lviewgen($view) 1
	} else {
	    incr lviewgen($view)
	}

	set args [tsv::get viewargs $view]
	if {[tsv::get viewfiles $view] ne {}} {
	    set args [concat $args "--" [tsv::get viewfiles $view]]
	}
	set order "--topo-order"
	if {$datemode} {
	    set order ""
	}
	if {[catch {
	    set fd [open [concat | git rev-list --header $order \
			      --parents --boundary --default HEAD $args] r]
	} err]} {
	    puts stderr "Error executing git rev-list: $err"
	    exit 1
	}
	set commfd($view) $fd
	set leftover($view) {}
	fconfigure $fd -translation lf
	%ifnotthread% fconfigure $fd -blocking 0
	if {$tclencoding != {}} {
	    fconfigure $fd -encoding $tclencoding
	}
	filerun $fd [list getcommitlines $fd $view]
    }

    proc stop_rev_list {} {
	global commfd curview

	if {![info exists commfd($curview)]} return
	set fd $commfd($curview)
	catch {
	    set pid [pid $fd]
	    exec kill $pid
	}
	catch {close $fd}
	unset commfd($curview)
    }

    # pull out row $row from disporder etc.
    proc extractrow {view row} {
	global commitidx disporder vtokenlist

	set id [lindex $disporder($view) $row]
	set disporder($view) [lreplace $disporder($view) $row $row]
	%iflthread% tsv::lpop disporder $view $row
	set vtokenlist($view) [lreplace $vtokenlist($view) $row $row]
	%iflthread% tsv::lpop vtokenlist $view $row
	tsv::unset ctok$view $id
	incr commitidx($view) -1
	return [list $id $l]
    }

    # move the first $fin entries in the reorder buffer to the
    # disporder etc. lists
    proc flushreorder {rebuf view fin} {
	global commitidx reorderbuf
	global vnexttoken disporder lviewgen vtokenlist vcmitlisted
	%ifnotlthread% global parents$view ctok$view

	if {$fin <= 0} {
	    set reorderbuf($view) $rebuf
	    return
	}
	set reorderbuf($view) [lrange $rebuf $fin end]
	set rebuf [lrange $rebuf 0 [expr {$fin-1}]]
	set oldlen $commitidx($view)
	incr commitidx($view) [llength $rebuf]
	set tok $vnexttoken($view)
	foreach info $rebuf {
	    set id [lindex $info 0]
	    lappend disporder($view) $id
	    lappend vcmitlisted($view) [lindex $info 2]
	    lappend vtokenlist($view) $tok
	    %tsvset% parents$view $id [lindex $info 1]
	    %tsvset% ctok$view $id $tok
	    incr tok
	}
	set vnexttoken($view) $tok
	%iflthread% eval tsv::linsert disporder $view end \
	    [lrange $disporder($view) $oldlen end]
	%iflthread% eval tsv::linsert vtokenlist $view end \
	    [lrange $vtokenlist($view) $oldlen end]
	%iflthread% eval tsv::linsert vcmitlisted $view end \
	    [lrange $vcmitlisted($view) $oldlen end]
	do_main newcommits $view $commitidx($view) $lviewgen($view)
    }

    # do a topological sort of the elements in l
    # each element is a list of ID, parents, children, listed flag
    proc topo_sort {l} {
	# simple, stupid sorting algorithm: keep moving commits back before
	# their earliest parent until we get to the end of the list.
	for {set i 0} {$i < [llength $l]} {incr i} {
	    set j $i
	    set info [lindex $l $i]
	    foreach p [lindex $info 1] {
		if {[info exists index($p)] && $index($p) < $j} {
		    set j $index($p)
		}
	    }
	    if {$j < $i} {
		# move this guy back to position $j
		set l [linsert [lreplace $l $i $i] $j $info]
		for {} {$i > $j} {incr i -1} {
		    unset index([lindex $l $i 0])
		}
	    }
	    set index([lindex $info 0]) $i
	}
	return $l
    }

    # called when input from the git rev-list process is available
    proc getcommitlines {fd view}  {
	global leftover commfd reorderbuf reorder_delay
	global misordered lviewgen
	global curview rowlaidout
	%ifnotthread% global children$view ctok$view cdata

	set rebuf $reorderbuf($view)
	set stuff [read $fd 500000]
	if {$stuff == {}} {
	    if {![eof $fd]} {
		return 1
	    }
	    flushreorder $rebuf $view [llength $rebuf]
	    unset commfd($view)
	    # set it blocking so we wait for the process to terminate
	    fconfigure $fd -blocking 1
	    set err {}
	    if {[catch {close $fd} err]} {
		set fv {}
		set vname [tsv::get viewname $view]
		if {$view != $curview} {
		    set fv " for the \"$vname\" view"
		}
		if {[string range $err 0 4] == "usage"} {
		    set err "Gitk: error reading commits$fv:\
			bad arguments to git rev-list."
		    if {$vname eq "Command line"} {
			append err \
			"  (Note: arguments to gitk are passed to git rev-list\
			 to allow selection of commits to be displayed.)"
		    }
		} else {
		    set err "Error reading commits$fv: $err"
		}
	    }
	    do_main viewdone $view $err $lviewgen($view)
	    if {$view == $curview} {
		run chewcommits
	    }
	    return 0
	}
	set i 0
	foreach x $rebuf {
	    set seenit([lindex $x 0]) $i
	    incr i
	}
	set start 0
	set gotsome 0
	while 1 {
	    set i [string first "\0" $stuff $start]
	    if {$i < 0} {
		append leftover($view) [string range $stuff $start end]
		break
	    }
	    if {$start == 0} {
		set cmit $leftover($view)
		append cmit [string range $stuff 0 [expr {$i - 1}]]
		set leftover($view) {}
	    } else {
		set cmit [string range $stuff $start [expr {$i - 1}]]
	    }
	    set start [expr {$i + 1}]
	    set j [string first "\n" $cmit]
	    set ok 0
	    set listed 1
	    if {$j >= 0} {
		set ids [string range $cmit 0 [expr {$j - 1}]]
		if {[string range $ids 0 0] == "-"} {
		    set listed 0
		    set ids [string range $ids 1 end]
		}
		set ok 1
		foreach id $ids {
		    if {[string length $id] != 40} {
			set ok 0
			break
		    }
		}
	    }
	    if {!$ok} {
		set shortcmit $cmit
		if {[string length $shortcmit] > 80} {
		    set shortcmit "[string range $shortcmit 0 80]..."
		}
		error_popup "Can't parse git rev-list output: {$shortcmit}"
		exit 1
	    }
	    set id [lindex $ids 0]
	    if {![%tsvexists% children$view $id]} {
		%tsvset% children$view $id {}
	    }
	    if {$listed} {
		set olds [lrange $ids 1 end]
		set i 0
		foreach p $olds {
		    if {$i == 0 || [lsearch -exact $olds $p] >= $i} {
			%tsvappend% children$view $p $id
		    }
		    incr i
		}
	    } else {
		set olds {}
	    }
	    %tsvset% cdata $id [string range $cmit [expr {$j + 1}] end]
	    set seenit($id) [llength $rebuf]
	    lappend rebuf [list $id $olds $listed]
	    set gotsome 1

	    # now check if we have already seen any of the parents already...
	    set pinfo {}
	    for {set i 0} {$i < [llength $olds]} {incr i} {
		set p [lindex $olds $i]
		if {[%tsvexists% ctok$view $p]} {
		    # got parent before child, parent has exited reorderbuf
		    # pull it out of the disporder etc. lists and
		    # append it to the reorderbuf
		    if {!$misordered($view)} {
			set misordered($view) 1
		    }
		    set r [rowofcommit $view $p]
		    do_main truncatecommits $view $r $lviewgen($view)
		    set info [extractrow $view $r]
		    # bump up reorder_delay to try to avoid this in future
		    set reorder_delay 500
		} elseif {[info exists seenit($p)]} {
		    # parent came first but is still in reorderbuf
		    # pull the parent entry out and append it again later
		    set r $seenit($p)
		    set info [lindex $rebuf $r]
		    set rebuf [lreplace $rebuf $r $r]
		    for {set l [llength $rebuf]} {$r < $l} {incr r} {
			set seenit([lindex $rebuf $r 0]) $r
		    }
		    unset seenit($p)
		} else {
		    continue
		}
		lappend pinfo $info
		# now make sure we check all of p's parents
		foreach pp [lindex $info 1] {
		    if {[lsearch -exact $olds $pp] < 0} {
			lappend olds $pp
		    }
		}
	    }
	    if {$pinfo ne {}} {
		# append parents that came earlier, in topological order
		foreach info [topo_sort $pinfo] {
		    set p [lindex $info 0]
		    set seenit($p) [llength $rebuf]
		    lappend rebuf $info
		}
	    }
	}
	if {$gotsome} {
	    flushreorder $rebuf $view [expr {[llength $rebuf]-$reorder_delay}]
	    if {$view == $curview} {
		run chewcommits
	    }
	}
	return 2
    }

    proc chewcommits {} {
	global curview misordered commfd curview lviewgen

	set more 0
	set allread [expr {![info exists commfd($curview)]}]
	set tlimit [expr {[clock clicks -milliseconds] + 50}]
	if {$allread && $misordered($curview)} {
	    # misordering was detected that we couldn't fix in the reorder
	    # buffer; re-do the layout from scratch
	    do_main showmisordered $curview $lviewgen($curview)
	    initlayout
	    # note initlayout clears misordered($curview)
	}
	if {!$misordered($curview)} {
	    set more [layoutmore $tlimit $allread]
	    if {$allread && !$more} {
		global commitidx lnumcommits startms
		if {$commitidx($curview) > 0} {
		    set ms [expr {[clock clicks -milliseconds] \
				      - $startms($curview)}]
		    #puts "overall $ms ms for $lnumcommits commits"
		}
	    }
	}
	return $more
    }

    proc layoutmore {tmax allread} {
	global rowlaidout rowoptim commitidx lnumcommits optim_delay
	global curview rowidlist idinlist lviewgen
	%ifnotthread% global options

	set showlast 0
	set showdelay $optim_delay
	set optdelay [expr {[%tsvget% options uparrowlen] + 1}]
	while {1} {
	    if {$rowoptim - $showdelay > $lnumcommits} {
		set canshow [expr {$rowoptim - $showdelay}]
		%iflthread% eval tsv::linsert vrowidlist $curview end \
		    [lrange $rowidlist $lnumcommits [expr {$canshow - 1}]]
		do_main showstuff $curview $canshow $showlast \
		    $lviewgen($curview)
		set lnumcommits $canshow
	    } elseif {$rowlaidout - $optdelay > $rowoptim} {
		set nr [expr {$rowlaidout - $optdelay - $rowoptim}]
		if {$nr > 100} {
		    set nr 100
		}
		optimize_rows $rowoptim 0 [expr {$rowoptim + $nr}]
		incr rowoptim $nr
	    } elseif {$commitidx($curview) > $rowlaidout} {
		set nr [expr {$commitidx($curview) - $rowlaidout}]
		# may need to increase this threshold if uparrowlen or
		# mingaplen are increased...
		if {$nr > 150} {
		    set nr 150
		}
		set row $rowlaidout
		set rowlaidout [layoutrows $row [expr {$row + $nr}] $allread]
		if {$rowlaidout == $row} {
		    return 0
		}
	    } elseif {$allread} {
		set optdelay 0
		set nrows $commitidx($curview)
		if {[lindex $rowidlist $nrows] ne {} ||
		    [array names idinlist] ne {}} {
		    layouttail
		    set rowlaidout $commitidx($curview)
		} elseif {$rowoptim == $nrows} {
		    set showdelay 0
		    set showlast 1
		    if {$lnumcommits == $nrows} {
			layout_finished
			return 0
		    }
		}
	    } else {
		return 0
	    }
	    if {$tmax ne {} && [clock clicks -milliseconds] >= $tmax} {
		return 1
	    }
	}
    }

    proc initlayout {} {
	global rowidlist rowoffsets rowlaidout rowoptim
	global idinlist rowchk
	global lnumcommits
	global curview misordered

	set rowlaidout 0
	set rowoptim 0
	set lnumcommits 0
	set rowidlist {{}}
	%iflthread% tsv::set vrowidlist $curview {}
	set rowoffsets {{}}
	catch {unset idinlist}
	catch {unset rowchk}
	catch {tsv::unset idrowranges$curview}
	set misordered($curview) 0
    }

    proc incrange {l x o} {
	set n [llength $l]
	while {$x < $n} {
	    set e [lindex $l $x]
	    if {$e ne {}} {
		lset l $x [expr {$e + $o}]
	    }
	    incr x
	}
	return $l
    }

    proc ntimes {n o} {
	set ret {}
	for {} {$n > 0} {incr n -1} {
	    lappend ret $o
	}
	return $ret
    }

    proc usedinrange {id l1 l2} {
	global curview disporder
	%ifnotthread% global ctok$curview children$curview

	set id1 [lindex $disporder($curview) $l1]
	set tok1 [%tsvget% ctok$curview $id1]
	set id2 [lindex $disporder($curview) $l2]
	set tok2 [%tsvget% ctok$curview $id2]
	if {[%tsvexists% ctok$curview $id]} {
	    set t [%tsvget% ctok$curview $id]
	    if {[tokencmp $tok1 $t] <= 0 && [tokencmp $t $tok2] <= 0} {
		set r [rowofcommit $curview $id]
		return [expr {$r - $l1 + 1}]
	    }
	}
	set kids [%tsvget% children$curview $id]
	foreach c $kids {
	    if {[%tsvexists% ctok$curview $c]} {
		set t [%tsvget% ctok$curview $c]
		if {[tokencmp $tok1 $t] <= 0 && [tokencmp $t $tok2] <= 0} {
		    set r [rowofcommit $curview $c]
		    return [expr {$r - $l1 + 1}]
		}
	    }
	}
	return 0
    }

    proc makeuparrow {oid x y z} {
	global rowidlist rowoffsets curview disporder
	%ifnotlthread% global idrowranges$curview options

	set uparrowlen [%tsvget% options uparrowlen]
	for {set i 1} {$i < $uparrowlen && $y > 1} {incr i} {
	    incr y -1
	    incr x $z
	    set off0 [lindex $rowoffsets $y]
	    for {set x0 $x} {1} {incr x0} {
		if {$x0 >= [llength $off0]} {
		    set x0 [llength [lindex $rowoffsets [expr {$y-1}]]]
		    break
		}
		set z [lindex $off0 $x0]
		if {$z ne {}} {
		    incr x0 $z
		    break
		}
	    }
	    set z [expr {$x0 - $x}]
	    lset rowidlist $y [linsert [lindex $rowidlist $y] $x $oid]
	    lset rowoffsets $y [linsert [lindex $rowoffsets $y] $x $z]
	}
	set tmp [lreplace [lindex $rowoffsets $y] $x $x {}]
	lset rowoffsets $y [incrange $tmp [expr {$x+1}] -1]
	%tsvappend% idrowranges$curview $oid [lindex $disporder($curview) $y]
    }

    proc layoutrows {row endrow last} {
	global rowidlist rowoffsets disporder
	global commitidx curview idinlist rowchk
	%ifnotlthread% global parents$curview children$curview \
	    idrowranges$curview options

	set maxwidth [%tsvget% options maxwidth]
	set uparrowlen [%tsvget% options uparrowlen]
	set downarrowlen [%tsvget% options downarrowlen]
	set mingaplen [%tsvget% options mingaplen]
	set idlist [lindex $rowidlist $row]
	set offs [lindex $rowoffsets $row]
	while {$row < $endrow} {
	    set id [lindex $disporder($curview) $row]
	    set oldolds {}
	    set newolds {}
	    foreach p [%tsvget% parents$curview $id] {
		if {![info exists idinlist($p)]} {
		    lappend newolds $p
		} elseif {!$idinlist($p)} {
		    lappend oldolds $p
		}
	    }
	    set nev [expr {[llength $idlist] + [llength $newolds]
			   + [llength $oldolds] - $maxwidth + 1}]
	    if {$nev > 0} {
		if {!$last &&
		    $row + $uparrowlen + $mingaplen >= $commitidx($curview)} break
		for {set x [llength $idlist]} {[incr x -1] >= 0} {} {
		    set i [lindex $idlist $x]
		    if {![info exists rowchk($i)] || $row >= $rowchk($i)} {
			set r [usedinrange $i [expr {$row - $downarrowlen}] \
				   [expr {$row + $uparrowlen + $mingaplen}]]
			if {$r == 0} {
			    set idlist [lreplace $idlist $x $x]
			    set offs [lreplace $offs $x $x]
			    set offs [incrange $offs $x 1]
			    set idinlist($i) 0
			    set rm1 [expr {$row - 1}]
			    %tsvappend% idrowranges$curview $i \
				[lindex $disporder($curview) $rm1]
			    if {[incr nev -1] <= 0} break
			    continue
			}
			set rowchk($id) [expr {$row + $r}]
		    }
		}
		lset rowidlist $row $idlist
		lset rowoffsets $row $offs
	    }
	    set col [lsearch -exact $idlist $id]
	    if {$col < 0} {
		set col [llength $idlist]
		lappend idlist $id
		lset rowidlist $row $idlist
		set z {}
		if {[%tsvget% children$curview $id] ne {}} {
		    set z [expr {[llength [lindex $rowidlist [expr {$row-1}]]] - $col}]
		    unset idinlist($id)
		}
		lappend offs $z
		lset rowoffsets $row $offs
		if {$z ne {}} {
		    makeuparrow $id $col $row $z
		}
	    } else {
		unset idinlist($id)
	    }
	    set ranges {}
	    if {[%tsvexists% idrowranges$curview $id]} {
		%tsvappend% idrowranges$curview $id $id
	    }
	    incr row
	    set offs [ntimes [llength $idlist] 0]
	    set l [llength $newolds]
	    set idlist [eval lreplace \$idlist $col $col $newolds]
	    set o 0
	    if {$l != 1} {
		set offs [lrange $offs 0 [expr {$col - 1}]]
		foreach x $newolds {
		    lappend offs {}
		    incr o -1
		}
		incr o
		set tmp [expr {[llength $idlist] - [llength $offs]}]
		if {$tmp > 0} {
		    set offs [concat $offs [ntimes $tmp $o]]
		}
	    } else {
		lset offs $col {}
	    }
	    foreach i $newolds {
		set idinlist($i) 1
		%tsvset% idrowranges$curview $i $id
	    }
	    incr col $l
	    foreach oid $oldolds {
		set idinlist($oid) 1
		set idlist [linsert $idlist $col $oid]
		set offs [linsert $offs $col $o]
		makeuparrow $oid $col $row $o
		incr col
	    }
	    lappend rowidlist $idlist
	    lappend rowoffsets $offs
	}
	return $row
    }

    proc addextraid {id row} {
	global vnexttoken disporder
	global commitidx
	global curview
	%ifnotthread% global parents$curview children$curview ctok$curview

	incr commitidx($curview)
	lappend disporder($curview) $id
	tsv::lpush vcmitlisted $curview 0 end
	%tsvset% parents$curview $id {}
	%tsvset% ctok$curview $id $vnexttoken($curview)
	incr vnexttoken($curview)
	if {![%tsvexists% children$curview $id]} {
	    %tsvset% children$curview $id {}
	}
    }

    proc layouttail {} {
	global rowidlist rowoffsets idinlist commitidx curview
	%ifnotlthread% global idrowranges$curview

	set row $commitidx($curview)
	set idlist [lindex $rowidlist $row]
	while {$idlist ne {}} {
	    set col [expr {[llength $idlist] - 1}]
	    set id [lindex $idlist $col]
	    addextraid $id $row
	    unset idinlist($id)
	    %tsvappend% idrowranges$curview $id $id
	    incr row
	    set offs [ntimes $col 0]
	    set idlist [lreplace $idlist $col $col]
	    lappend rowidlist $idlist
	    lappend rowoffsets $offs
	}

	foreach id [array names idinlist] {
	    unset idinlist($id)
	    addextraid $id $row
	    lset rowidlist $row [list $id]
	    lset rowoffsets $row 0
	    makeuparrow $id 0 $row 0
	    %tsvappend% idrowranges$curview $id $id
	    incr row
	    lappend rowidlist {}
	    lappend rowoffsets {}
	}
    }

    proc insert_pad {row col npad} {
	global rowidlist rowoffsets curview

	set pad [ntimes $npad {}]
	lset rowidlist $row [eval linsert [list [lindex $rowidlist $row]] $col $pad]
	set tmp [eval linsert [list [lindex $rowoffsets $row]] $col $pad]
	lset rowoffsets $row [incrange $tmp [expr {$col + $npad}] [expr {-$npad}]]
    }

    proc optimize_rows {row col endrow} {
	global rowidlist rowoffsets curview disporder
	global children$curview

	for {} {$row < $endrow} {incr row} {
	    set idlist [lindex $rowidlist $row]
	    set offs [lindex $rowoffsets $row]
	    set haspad 0
	    for {} {$col < [llength $offs]} {incr col} {
		set id [lindex $idlist $col]
		if {$id eq {}} {
		    set haspad 1
		    continue
		}
		set z [lindex $offs $col]
		if {$z eq {}} continue
		set isarrow 0
		set x0 [expr {$col + $z}]
		set y0 [expr {$row - 1}]
		set z0 [lindex $rowoffsets $y0 $x0]
		if {$z0 eq {}} {
		    set kid [lindex $disporder($curview) [expr {$row - 2}]]
		    if {[%tsvsearch% children$curview $id $kid] < 0} {
			set isarrow 1
		    }
		}
		# Looking at lines from this row to the previous row,
		# make them go straight up if they end in an arrow on
		# the previous row; otherwise make them go straight up
		# or at 45 degrees.
		if {$z < -1 || ($z < 0 && $isarrow)} {
		    # Line currently goes left too much;
		    # insert pads in the previous row, then optimize it
		    set npad [expr {-1 - $z + $isarrow}]
		    set offs [incrange $offs $col $npad]
		    insert_pad $y0 $x0 $npad
		    if {$y0 > 0} {
			optimize_rows $y0 $x0 $row
		    }
		    set z [lindex $offs $col]
		    set x0 [expr {$col + $z}]
		    set z0 [lindex $rowoffsets $y0 $x0]
		} elseif {$z > 1 || ($z > 0 && $isarrow)} {
		    # Line currently goes right too much;
		    # insert pads in this line and adjust the next's rowoffsets
		    set npad [expr {$z - 1 + $isarrow}]
		    set y1 [expr {$row + 1}]
		    set offs2 [lindex $rowoffsets $y1]
		    set x1 -1
		    foreach z $offs2 {
			incr x1
			if {$z eq {} || $x1 + $z < $col} continue
			if {$x1 + $z > $col} {
			    incr npad
			}
			lset rowoffsets $y1 [incrange $offs2 $x1 $npad]
			break
		    }
		    set pad [ntimes $npad {}]
		    set idlist [eval linsert \$idlist $col $pad]
		    set tmp [eval linsert \$offs $col $pad]
		    incr col $npad
		    set offs [incrange $tmp $col [expr {-$npad}]]
		    set z [lindex $offs $col]
		    set haspad 1
		}
		if {$z0 eq {} && !$isarrow} {
		    # this line links to its first child on row $row-2
		    set rm2 [expr {$row - 2}]
		    set id [lindex $disporder($curview) $rm2]
		    set xc [lsearch -exact [lindex $rowidlist $rm2] $id]
		    if {$xc >= 0} {
			set z0 [expr {$xc - $x0}]
		    }
		}
		# avoid lines jigging left then immediately right
		if {$z0 ne {} && $z < 0 && $z0 > 0} {
		    insert_pad $y0 $x0 1
		    set offs [incrange $offs $col 1]
		    optimize_rows $y0 [expr {$x0 + 1}] $row
		}
	    }
	    if {!$haspad} {
		set o {}
		# Find the first column that doesn't have a line going right
		for {set col [llength $idlist]} {[incr col -1] >= 0} {} {
		    set o [lindex $offs $col]
		    if {$o eq {}} {
			# check if this is the link to the first child
			set id [lindex $idlist $col]
			set y0 [expr {$row - 1}]
			set kid [lindex $disporder($curview) $y0]
			if {[%tsvsearch% children$curview $id $kid] >= 0} {
			    # it is, work out offset to child
			    set x0 [lsearch -exact [lindex $rowidlist $y0] $kid]
			    if {$x0 >= 0} {
				set o [expr {$x0 - $col}]
			    }
			}
		    }
		    if {$o eq {} || $o <= 0} break
		}
		# Insert a pad at that column as long as it has a line and
		# isn't the last column, and adjust the next row' offsets
		if {$o ne {} && [incr col] < [llength $idlist]} {
		    set y1 [expr {$row + 1}]
		    set offs2 [lindex $rowoffsets $y1]
		    set x1 -1
		    foreach z $offs2 {
			incr x1
			if {$z eq {} || $x1 + $z < $col} continue
			lset rowoffsets $y1 [incrange $offs2 $x1 1]
			break
		    }
		    set idlist [linsert $idlist $col {}]
		    set tmp [linsert $offs $col {}]
		    incr col
		    set offs [incrange $tmp $col -1]
		}
	    }
	    lset rowidlist $row $idlist
	    lset rowoffsets $row $offs
	    set col 0
	}
    }

    set optim_delay 16
    set reorder_delay 10
}

proc getcommits {view} {
    global phase canv mainfont viewstate viewgen curview
    global lookingforhead 

    nowbusy layout
    nowbusy $view
    set phase getcommits
    set viewstate($view) 0
    do_layout start_layout $view
    init_screen
    show_status "Reading commits..."
    if {![info exists viewgen($view)]} {
	set viewgen($view) 1
    } else {
	incr viewgen($view)
    }
    set curview $view
    set lookingforhead [tsv::get options showlocalchanges]
}

proc read_revs {view} {
    global viewstate

    set viewstate($view) 0
    nowbusy $view
    do_layout start_rev_list $view
    if {![info exists viewgen($curview)]} {
	set viewgen($curview) 1
    } else {
	incr viewgen($curview)
    }
}

proc viewdone {view err gen} {
    global viewstate viewgen

    if {$viewgen($view) != $gen} return
    set viewstate($view) 1
    notbusy $view
    if {$err ne {}} {
	error_popup $err
    }
}

proc readcommit {id} {
    if {[catch {set contents [exec git cat-file commit $id]}]} return
    parsecommit $id $contents 0
}

proc reloadcommits {} {
    global selectedline thickerline curview

    catch {unset selectedline}
    catch {unset thickerline}
    catch {unset matchinglines}
    catch {unset treediffs}
    discardallcommits
    stopfindproc
    readrefs
    getcommits $curview
}

proc parsecommit {id contents listed} {
    global cdate

    set inhdr 1
    set comment {}
    set headline {}
    set auname {}
    set audate {}
    set comname {}
    set comdate {}
    set hdrend [string first "\n\n" $contents]
    if {$hdrend < 0} {
	# should never happen...
	set hdrend [string length $contents]
    }
    set header [string range $contents 0 [expr {$hdrend - 1}]]
    set comment [string range $contents [expr {$hdrend + 2}] end]
    foreach line [split $header "\n"] {
	set tag [lindex $line 0]
	if {$tag == "author"} {
	    set audate [lindex $line end-1]
	    set auname [lrange $line 1 end-2]
	} elseif {$tag == "committer"} {
	    set comdate [lindex $line end-1]
	    set comname [lrange $line 1 end-2]
	}
    }
    set headline {}
    # take the first non-blank line of the comment as the headline
    set headline [string trimleft $comment]
    set i [string first "\n" $headline]
    if {$i >= 0} {
	set headline [string range $headline 0 $i]
    }
    set headline [string trimright $headline]
    set i [string first "\r" $headline]
    if {$i >= 0} {
	set headline [string trimright [string range $headline 0 $i]]
    }
    if {!$listed} {
	# git rev-list indents the comment by 4 spaces;
	# if we got this via git cat-file, add the indentation
	set newcomment {}
	foreach line [split $comment "\n"] {
	    append newcomment "    "
	    append newcomment $line
	    append newcomment "\n"
	}
	set comment $newcomment
    }
    if {$comdate != {}} {
	set cdate($id) $comdate
    }
    tsv::set commitinfo $id [list $headline $auname $audate \
				 $comname $comdate $comment]
}

proc getcommit {id} {
    if {[tsv::exists cdata $id]} {
	parsecommit $id [tsv::get cdata $id] 1
    } else {
	readcommit $id
	if {![tsv::exists commitinfo $id]} {
	    tsv::set commitinfo $id {"No commit information available"}
	}
    }
    return 1
}

proc readrefs {} {
    global tagids headids tagobjid
    global otherrefids idotherrefs mainhead mainheadid

    foreach v {tagids headids otherrefids idotherrefs} {
	catch {unset $v}
    }
    catch {tsv::unset idtags}
    catch {tsv::unset idheads}
    set refd [open [list | git ls-remote [gitdir]] r]
    while {[gets $refd line] >= 0} {
	set e [split $line "\t"]
	if {[llength $e] != 2} continue
	set id [lindex $e 0]
	set ref [lindex $e 1]
	if {[string length $id] != 40 || ![string match "refs/*" $ref]} {
	    continue
	}
	set name [string range $ref 5 end]
	if {[string match "remotes/*" $name]} {
	    if {![string match "*/HEAD" $name]} {
		set headids($name) $id
		tsv::lpush idheads $id $name end
	    }
	} elseif {[string match "heads/*" $name]} {
	    set name [string range $name 6 end]
	    set headids($name) $id
	    tsv::lpush idheads $id $name end
	} elseif {[string match "tags/*" $name]} {
	    # this lets refs/tags/foo^{} overwrite refs/tags/foo,
	    # which is what we want since the former is the commit ID
	    set name [string range $name 5 end]
	    if {[string match "*^{}" $name]} {
		set name [string range $name 0 end-3]
	    } else {
		set tagobjid($name) $id
	    }
	    set tagids($name) $id
	    tsv::lpush idtags $id $name end
	} else {
	    set otherrefids($name) $id
	    lappend idotherrefs($id) $name
	}
    }
    close $refd
    set mainhead {}
    set mainheadid {}
    catch {
	set thehead [exec git symbolic-ref HEAD]
	if {[string match "refs/heads/*" $thehead]} {
	    set mainhead [string range $thehead 11 end]
	    if {[info exists headids($mainhead)]} {
		set mainheadid $headids($mainhead)
	    }
	}
    }
}

proc show_error {w top msg} {
    message $w.m -text $msg -justify center -aspect 400
    pack $w.m -side top -fill x -padx 20 -pady 20
    button $w.ok -text OK -command "destroy $top"
    pack $w.ok -side bottom -fill x
    bind $top <Visibility> "grab $top; focus $top"
    bind $top <Key-Return> "destroy $top"
    tkwait window $top
}

proc error_popup msg {
    set w .error
    toplevel $w
    wm transient $w .
    show_error $w $w $msg
}

proc confirm_popup msg {
    global confirm_ok
    set confirm_ok 0
    set w .confirm
    toplevel $w
    wm transient $w .
    message $w.m -text $msg -justify center -aspect 400
    pack $w.m -side top -fill x -padx 20 -pady 20
    button $w.ok -text OK -command "set confirm_ok 1; destroy $w"
    pack $w.ok -side left -fill x
    button $w.cancel -text Cancel -command "destroy $w"
    pack $w.cancel -side right -fill x
    bind $w <Visibility> "grab $w; focus $w"
    tkwait window $w
    return $confirm_ok
}

proc makewindow {} {
    global canv canv2 canv3 linespc charspc ctext cflist
    global textfont mainfont uifont
    global findtype findtypemenu findloc findstring fstring geometry
    global entries sha1entry sha1string sha1but
    global maincursor textcursor curtextcursor
    global rowctxmenu fakerowmenu mergemax wrapcomment
    global highlight_files gdttype
    global searchstring sstring
    global bgcolor fgcolor bglist fglist diffcolors
    global headctxmenu

    menu .bar
    .bar add cascade -label "File" -menu .bar.file
    .bar configure -font $uifont
    menu .bar.file
    .bar.file add command -label "Reload" -command reloadcommits
    .bar.file add command -label "Reread references" -command rereadrefs
    .bar.file add command -label "Quit" -command doquit
    .bar.file configure -font $uifont
    menu .bar.edit
    .bar add cascade -label "Edit" -menu .bar.edit
    .bar.edit add command -label "Preferences" -command doprefs
    .bar.edit configure -font $uifont

    menu .bar.view -font $uifont
    .bar add cascade -label "View" -menu .bar.view
    .bar.view add command -label "New view..." -command {newview 0}
    .bar.view add command -label "Edit view..." -command editview \
	-state disabled
    .bar.view add command -label "Delete view" -command delview -state disabled
    .bar.view add separator
    .bar.view add radiobutton -label "All files" -command {showview 0} \
	-variable selectedview -value 0
    
    menu .bar.help
    .bar add cascade -label "Help" -menu .bar.help
    .bar.help add command -label "About gitk" -command about
    .bar.help add command -label "Key bindings" -command keys
    .bar.help configure -font $uifont
    . configure -menu .bar

    if {![info exists geometry(canv1)]} {
	set geometry(canv1) [expr {45 * $charspc}]
	set geometry(canv2) [expr {30 * $charspc}]
	set geometry(canv3) [expr {15 * $charspc}]
	set geometry(canvh) [expr {25 * $linespc + 4}]
	set geometry(ctextw) 80
	set geometry(ctexth) 30
	set geometry(cflistw) 30
    }
    panedwindow .ctop -orient vertical
    if {[info exists geometry(width)]} {
	.ctop conf -width $geometry(width) -height $geometry(height)
	set texth [expr {$geometry(height) - $geometry(canvh) - 56}]
	set geometry(ctexth) [expr {($texth - 8) /
				    [font metrics $textfont -linespace]}]
    }
    frame .ctop.top
    frame .ctop.top.bar
    frame .ctop.top.lbar
    pack .ctop.top.lbar -side bottom -fill x
    pack .ctop.top.bar -side bottom -fill x
    set cscroll .ctop.top.csb
    scrollbar $cscroll -command {allcanvs yview} -highlightthickness 0
    pack $cscroll -side right -fill y
    panedwindow .ctop.top.clist -orient horizontal -sashpad 0 -handlesize 4
    pack .ctop.top.clist -side top -fill both -expand 1
    .ctop add .ctop.top
    set canv .ctop.top.clist.canv
    canvas $canv -height $geometry(canvh) -width $geometry(canv1) \
	-background $bgcolor -bd 0 \
	-yscrollincr $linespc -yscrollcommand "scrollcanv $cscroll"
    .ctop.top.clist add $canv
    set canv2 .ctop.top.clist.canv2
    canvas $canv2 -height $geometry(canvh) -width $geometry(canv2) \
	-background $bgcolor -bd 0 -yscrollincr $linespc
    .ctop.top.clist add $canv2
    set canv3 .ctop.top.clist.canv3
    canvas $canv3 -height $geometry(canvh) -width $geometry(canv3) \
	-background $bgcolor -bd 0 -yscrollincr $linespc
    .ctop.top.clist add $canv3
    bind .ctop.top.clist <Configure> {resizeclistpanes %W %w}
    lappend bglist $canv $canv2 $canv3

    set sha1entry .ctop.top.bar.sha1
    set entries $sha1entry
    set sha1but .ctop.top.bar.sha1label
    button $sha1but -text "SHA1 ID: " -state disabled -relief flat \
	-command gotocommit -width 8 -font $uifont
    $sha1but conf -disabledforeground [$sha1but cget -foreground]
    pack .ctop.top.bar.sha1label -side left
    entry $sha1entry -width 40 -font $textfont -textvariable sha1string
    trace add variable sha1string write sha1change
    pack $sha1entry -side left -pady 2

    image create bitmap bm-left -data {
	#define left_width 16
	#define left_height 16
	static unsigned char left_bits[] = {
	0x00, 0x00, 0xc0, 0x01, 0xe0, 0x00, 0x70, 0x00, 0x38, 0x00, 0x1c, 0x00,
	0x0e, 0x00, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0x0e, 0x00, 0x1c, 0x00,
	0x38, 0x00, 0x70, 0x00, 0xe0, 0x00, 0xc0, 0x01};
    }
    image create bitmap bm-right -data {
	#define right_width 16
	#define right_height 16
	static unsigned char right_bits[] = {
	0x00, 0x00, 0xc0, 0x01, 0x80, 0x03, 0x00, 0x07, 0x00, 0x0e, 0x00, 0x1c,
	0x00, 0x38, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0x00, 0x38, 0x00, 0x1c,
	0x00, 0x0e, 0x00, 0x07, 0x80, 0x03, 0xc0, 0x01};
    }
    button .ctop.top.bar.leftbut -image bm-left -command goback \
	-state disabled -width 26
    pack .ctop.top.bar.leftbut -side left -fill y
    button .ctop.top.bar.rightbut -image bm-right -command goforw \
	-state disabled -width 26
    pack .ctop.top.bar.rightbut -side left -fill y

    button .ctop.top.bar.findbut -text "Find" -command dofind -font $uifont
    pack .ctop.top.bar.findbut -side left
    set findstring {}
    set fstring .ctop.top.bar.findstring
    lappend entries $fstring
    entry $fstring -width 30 -font $textfont -textvariable findstring
    trace add variable findstring write find_change
    pack $fstring -side left -expand 1 -fill x
    set findtype Exact
    set findtypemenu [tk_optionMenu .ctop.top.bar.findtype \
			  findtype Exact IgnCase Regexp]
    trace add variable findtype write find_change
    .ctop.top.bar.findtype configure -font $uifont
    .ctop.top.bar.findtype.menu configure -font $uifont
    set findloc "All fields"
    tk_optionMenu .ctop.top.bar.findloc findloc "All fields" Headline \
	Comments Author Committer
    trace add variable findloc write find_change
    .ctop.top.bar.findloc configure -font $uifont
    .ctop.top.bar.findloc.menu configure -font $uifont
    pack .ctop.top.bar.findloc -side right
    pack .ctop.top.bar.findtype -side right

    label .ctop.top.lbar.flabel -text "Highlight:  Commits " \
	-font $uifont
    pack .ctop.top.lbar.flabel -side left -fill y
    set gdttype "touching paths:"
    set gm [tk_optionMenu .ctop.top.lbar.gdttype gdttype "touching paths:" \
		"adding/removing string:"]
    trace add variable gdttype write hfiles_change
    $gm conf -font $uifont
    .ctop.top.lbar.gdttype conf -font $uifont
    pack .ctop.top.lbar.gdttype -side left -fill y
    entry .ctop.top.lbar.fent -width 25 -font $textfont \
	-textvariable highlight_files
    trace add variable highlight_files write hfiles_change
    lappend entries .ctop.top.lbar.fent
    pack .ctop.top.lbar.fent -side left -fill x -expand 1
    label .ctop.top.lbar.vlabel -text " OR in view" -font $uifont
    pack .ctop.top.lbar.vlabel -side left -fill y
    global viewhlmenu selectedhlview
    set viewhlmenu [tk_optionMenu .ctop.top.lbar.vhl selectedhlview None]
    $viewhlmenu entryconf 0 -command delvhighlight
    $viewhlmenu conf -font $uifont
    .ctop.top.lbar.vhl conf -font $uifont
    pack .ctop.top.lbar.vhl -side left -fill y
    label .ctop.top.lbar.rlabel -text " OR " -font $uifont
    pack .ctop.top.lbar.rlabel -side left -fill y
    global highlight_related
    set m [tk_optionMenu .ctop.top.lbar.relm highlight_related None \
	       "Descendent" "Not descendent" "Ancestor" "Not ancestor"]
    $m conf -font $uifont
    .ctop.top.lbar.relm conf -font $uifont
    trace add variable highlight_related write vrel_change
    pack .ctop.top.lbar.relm -side left -fill y

    panedwindow .ctop.cdet -orient horizontal
    .ctop add .ctop.cdet
    frame .ctop.cdet.left
    frame .ctop.cdet.left.bot
    pack .ctop.cdet.left.bot -side bottom -fill x
    button .ctop.cdet.left.bot.search -text "Search" -command dosearch \
	-font $uifont
    pack .ctop.cdet.left.bot.search -side left -padx 5
    set sstring .ctop.cdet.left.bot.sstring
    entry $sstring -width 20 -font $textfont -textvariable searchstring
    lappend entries $sstring
    trace add variable searchstring write incrsearch
    pack $sstring -side left -expand 1 -fill x
    set ctext .ctop.cdet.left.ctext
    text $ctext -background $bgcolor -foreground $fgcolor \
	-state disabled -font $textfont \
	-width $geometry(ctextw) -height $geometry(ctexth) \
	-yscrollcommand scrolltext -wrap none
    scrollbar .ctop.cdet.left.sb -command "$ctext yview"
    pack .ctop.cdet.left.sb -side right -fill y
    pack $ctext -side left -fill both -expand 1
    .ctop.cdet add .ctop.cdet.left
    lappend bglist $ctext
    lappend fglist $ctext

    $ctext tag conf comment -wrap $wrapcomment
    $ctext tag conf filesep -font [concat $textfont bold] -back "#aaaaaa"
    $ctext tag conf hunksep -fore [lindex $diffcolors 2]
    $ctext tag conf d0 -fore [lindex $diffcolors 0]
    $ctext tag conf d1 -fore [lindex $diffcolors 1]
    $ctext tag conf m0 -fore red
    $ctext tag conf m1 -fore blue
    $ctext tag conf m2 -fore green
    $ctext tag conf m3 -fore purple
    $ctext tag conf m4 -fore brown
    $ctext tag conf m5 -fore "#009090"
    $ctext tag conf m6 -fore magenta
    $ctext tag conf m7 -fore "#808000"
    $ctext tag conf m8 -fore "#009000"
    $ctext tag conf m9 -fore "#ff0080"
    $ctext tag conf m10 -fore cyan
    $ctext tag conf m11 -fore "#b07070"
    $ctext tag conf m12 -fore "#70b0f0"
    $ctext tag conf m13 -fore "#70f0b0"
    $ctext tag conf m14 -fore "#f0b070"
    $ctext tag conf m15 -fore "#ff70b0"
    $ctext tag conf mmax -fore darkgrey
    set mergemax 16
    $ctext tag conf mresult -font [concat $textfont bold]
    $ctext tag conf msep -font [concat $textfont bold]
    $ctext tag conf found -back yellow

    frame .ctop.cdet.right
    frame .ctop.cdet.right.mode
    radiobutton .ctop.cdet.right.mode.patch -text "Patch" \
	-command reselectline -variable cmitmode -value "patch"
    radiobutton .ctop.cdet.right.mode.tree -text "Tree" \
	-command reselectline -variable cmitmode -value "tree"
    grid .ctop.cdet.right.mode.patch .ctop.cdet.right.mode.tree -sticky ew
    pack .ctop.cdet.right.mode -side top -fill x
    set cflist .ctop.cdet.right.cfiles
    set indent [font measure $mainfont "nn"]
    text $cflist -width $geometry(cflistw) \
	-background $bgcolor -foreground $fgcolor \
	-font $mainfont \
	-tabs [list $indent [expr {2 * $indent}]] \
	-yscrollcommand ".ctop.cdet.right.sb set" \
	-cursor [. cget -cursor] \
	-spacing1 1 -spacing3 1
    lappend bglist $cflist
    lappend fglist $cflist
    scrollbar .ctop.cdet.right.sb -command "$cflist yview"
    pack .ctop.cdet.right.sb -side right -fill y
    pack $cflist -side left -fill both -expand 1
    $cflist tag configure highlight \
	-background [$cflist cget -selectbackground]
    $cflist tag configure bold -font [concat $mainfont bold]
    .ctop.cdet add .ctop.cdet.right
    bind .ctop.cdet <Configure> {resizecdetpanes %W %w}

    pack .ctop -side top -fill both -expand 1

    bindall <1> {selcanvline %W %x %y}
    #bindall <B1-Motion> {selcanvline %W %x %y}
    bindall <ButtonRelease-4> "allcanvs yview scroll -5 units"
    bindall <ButtonRelease-5> "allcanvs yview scroll 5 units"
    bindall <2> "canvscan mark %W %x %y"
    bindall <B2-Motion> "canvscan dragto %W %x %y"
    bindkey <Home> selfirstline
    bindkey <End> sellastline
    bind . <Key-Up> "selnextline -1"
    bind . <Key-Down> "selnextline 1"
    bind . <Shift-Key-Up> "next_highlight -1"
    bind . <Shift-Key-Down> "next_highlight 1"
    bindkey <Key-Right> "goforw"
    bindkey <Key-Left> "goback"
    bind . <Key-Prior> "selnextpage -1"
    bind . <Key-Next> "selnextpage 1"
    bind . <Control-Home> "allcanvs yview moveto 0.0"
    bind . <Control-End> "allcanvs yview moveto 1.0"
    bind . <Control-Key-Up> "allcanvs yview scroll -1 units"
    bind . <Control-Key-Down> "allcanvs yview scroll 1 units"
    bind . <Control-Key-Prior> "allcanvs yview scroll -1 pages"
    bind . <Control-Key-Next> "allcanvs yview scroll 1 pages"
    bindkey <Key-Delete> "$ctext yview scroll -1 pages"
    bindkey <Key-BackSpace> "$ctext yview scroll -1 pages"
    bindkey <Key-space> "$ctext yview scroll 1 pages"
    bindkey p "selnextline -1"
    bindkey n "selnextline 1"
    bindkey z "goback"
    bindkey x "goforw"
    bindkey i "selnextline -1"
    bindkey k "selnextline 1"
    bindkey j "goback"
    bindkey l "goforw"
    bindkey b "$ctext yview scroll -1 pages"
    bindkey d "$ctext yview scroll 18 units"
    bindkey u "$ctext yview scroll -18 units"
    bindkey / {findnext 1}
    bindkey <Key-Return> {findnext 0}
    bindkey ? findprev
    bindkey f nextfile
    bind . <Control-q> doquit
    bind . <Control-f> dofind
    bind . <Control-g> {findnext 0}
    bind . <Control-r> dosearchback
    bind . <Control-s> dosearch
    bind . <Control-equal> {incrfont 1}
    bind . <Control-KP_Add> {incrfont 1}
    bind . <Control-minus> {incrfont -1}
    bind . <Control-KP_Subtract> {incrfont -1}
    bind . <Destroy> {savestuff %W}
    bind . <Button-1> "click %W"
    bind $fstring <Key-Return> dofind
    bind $sha1entry <Key-Return> gotocommit
    bind $sha1entry <<PasteSelection>> clearsha1
    bind $cflist <1> {sel_flist %W %x %y; break}
    bind $cflist <B1-Motion> {sel_flist %W %x %y; break}
    bind $cflist <ButtonRelease-1> {treeclick %W %x %y}

    set maincursor [. cget -cursor]
    set textcursor [$ctext cget -cursor]
    set curtextcursor $textcursor

    set rowctxmenu .rowctxmenu
    menu $rowctxmenu -tearoff 0
    $rowctxmenu add command -label "Diff this -> selected" \
	-command {diffvssel 0}
    $rowctxmenu add command -label "Diff selected -> this" \
	-command {diffvssel 1}
    $rowctxmenu add command -label "Make patch" -command mkpatch
    $rowctxmenu add command -label "Create tag" -command mktag
    $rowctxmenu add command -label "Write commit to file" -command writecommit
    $rowctxmenu add command -label "Create new branch" -command mkbranch
    $rowctxmenu add command -label "Cherry-pick this commit" \
	-command cherrypick
    $rowctxmenu add command -label "Reset HEAD branch to here" \
	-command resethead

    set fakerowmenu .fakerowmenu
    menu $fakerowmenu -tearoff 0
    $fakerowmenu add command -label "Diff this -> selected" \
	-command {diffvssel 0}
    $fakerowmenu add command -label "Diff selected -> this" \
	-command {diffvssel 1}
    $fakerowmenu add command -label "Make patch" -command mkpatch
#    $fakerowmenu add command -label "Commit" -command {mkcommit 0}
#    $fakerowmenu add command -label "Commit all" -command {mkcommit 1}
#    $fakerowmenu add command -label "Revert local changes" -command revertlocal

    set headctxmenu .headctxmenu
    menu $headctxmenu -tearoff 0
    $headctxmenu add command -label "Check out this branch" \
	-command cobranch
    $headctxmenu add command -label "Remove this branch" \
	-command rmbranch
}

# mouse-2 makes all windows scan vertically, but only the one
# the cursor is in scans horizontally
proc canvscan {op w x y} {
    global canv canv2 canv3
    foreach c [list $canv $canv2 $canv3] {
	if {$c == $w} {
	    $c scan $op $x $y
	} else {
	    $c scan $op 0 $y
	}
    }
}

proc scrollcanv {cscroll f0 f1} {
    $cscroll set $f0 $f1
    drawfrac $f0 $f1
    flushhighlights
}

# when we make a key binding for the toplevel, make sure
# it doesn't get triggered when that key is pressed in the
# find string entry widget.
proc bindkey {ev script} {
    global entries
    bind . $ev $script
    set escript [bind Entry $ev]
    if {$escript == {}} {
	set escript [bind Entry <Key>]
    }
    foreach e $entries {
	bind $e $ev "$escript; break"
    }
}

# set the focus back to the toplevel for any click outside
# the entry widgets
proc click {w} {
    global entries
    foreach e $entries {
	if {$w == $e} return
    }
    focus .
}

proc savestuff {w} {
    global canv canv2 canv3 ctext cflist mainfont textfont uifont
    global stuffsaved findmergefiles maxgraphpct
    global showneartags
    global viewperm nextviewnum
    global cmitmode wrapcomment
    global colors bgcolor fgcolor diffcolors

    if {$stuffsaved} return
    if {![winfo viewable .]} return
    catch {
	set f [open "~/.gitk-new" w]
	puts $f [list set mainfont $mainfont]
	puts $f [list set textfont $textfont]
	puts $f [list set uifont $uifont]
	puts $f [list set findmergefiles $findmergefiles]
	puts $f [list set maxgraphpct $maxgraphpct]
	puts $f [list set maxwidth [tsv::get options maxwidth]]
	puts $f [list set cmitmode $cmitmode]
	puts $f [list set wrapcomment $wrapcomment]
	puts $f [list set showneartags $showneartags]
	puts $f [list set showlocalchanges [tsv::get options showlocalchanges]]
	puts $f [list set bgcolor $bgcolor]
	puts $f [list set fgcolor $fgcolor]
	puts $f [list set colors $colors]
	puts $f [list set diffcolors $diffcolors]
	puts $f "set geometry(width) [winfo width .ctop]"
	puts $f "set geometry(height) [winfo height .ctop]"
	puts $f "set geometry(canv1) [expr {[winfo width $canv]-2}]"
	puts $f "set geometry(canv2) [expr {[winfo width $canv2]-2}]"
	puts $f "set geometry(canv3) [expr {[winfo width $canv3]-2}]"
	puts $f "set geometry(canvh) [expr {[winfo height $canv]-2}]"
	set wid [expr {([winfo width $ctext] - 8) \
			   / [font measure $textfont "0"]}]
	puts $f "set geometry(ctextw) $wid"
	set wid [expr {([winfo width $cflist] - 11) \
			   / [font measure [$cflist cget -font] "0"]}]
	puts $f "set geometry(cflistw) $wid"
	puts -nonewline $f "set permviews {"
	for {set v 0} {$v < $nextviewnum} {incr v} {
	    if {$viewperm($v)} {
		puts $f "{[list [tsv::get viewname $v] \
			 [tsv::get viewfiles $v] [tsv::get viewargs $v]]}"
	    }
	}
	puts $f "}"
	close $f
	file rename -force "~/.gitk-new" "~/.gitk"
    }
    set stuffsaved 1
}

proc resizeclistpanes {win w} {
    global oldwidth
    if {[info exists oldwidth($win)]} {
	set s0 [$win sash coord 0]
	set s1 [$win sash coord 1]
	if {$w < 60} {
	    set sash0 [expr {int($w/2 - 2)}]
	    set sash1 [expr {int($w*5/6 - 2)}]
	} else {
	    set factor [expr {1.0 * $w / $oldwidth($win)}]
	    set sash0 [expr {int($factor * [lindex $s0 0])}]
	    set sash1 [expr {int($factor * [lindex $s1 0])}]
	    if {$sash0 < 30} {
		set sash0 30
	    }
	    if {$sash1 < $sash0 + 20} {
		set sash1 [expr {$sash0 + 20}]
	    }
	    if {$sash1 > $w - 10} {
		set sash1 [expr {$w - 10}]
		if {$sash0 > $sash1 - 20} {
		    set sash0 [expr {$sash1 - 20}]
		}
	    }
	}
	$win sash place 0 $sash0 [lindex $s0 1]
	$win sash place 1 $sash1 [lindex $s1 1]
    }
    set oldwidth($win) $w
}

proc resizecdetpanes {win w} {
    global oldwidth
    if {[info exists oldwidth($win)]} {
	set s0 [$win sash coord 0]
	if {$w < 60} {
	    set sash0 [expr {int($w*3/4 - 2)}]
	} else {
	    set factor [expr {1.0 * $w / $oldwidth($win)}]
	    set sash0 [expr {int($factor * [lindex $s0 0])}]
	    if {$sash0 < 45} {
		set sash0 45
	    }
	    if {$sash0 > $w - 15} {
		set sash0 [expr {$w - 15}]
	    }
	}
	$win sash place 0 $sash0 [lindex $s0 1]
    }
    set oldwidth($win) $w
}

proc allcanvs args {
    global canv canv2 canv3
    eval $canv $args
    eval $canv2 $args
    eval $canv3 $args
}

proc bindall {event action} {
    global canv canv2 canv3
    bind $canv $event $action
    bind $canv2 $event $action
    bind $canv3 $event $action
}

proc about {} {
    set w .about
    if {[winfo exists $w]} {
	raise $w
	return
    }
    toplevel $w
    wm title $w "About gitk"
    message $w.m -text {
Gitk - a commit viewer for git

Copyright  2005-2006 Paul Mackerras

Use and redistribute under the terms of the GNU General Public License} \
	    -justify center -aspect 400
    pack $w.m -side top -fill x -padx 20 -pady 20
    button $w.ok -text Close -command "destroy $w"
    pack $w.ok -side bottom
}

proc keys {} {
    set w .keys
    if {[winfo exists $w]} {
	raise $w
	return
    }
    toplevel $w
    wm title $w "Gitk key bindings"
    message $w.m -text {
Gitk key bindings:

<Ctrl-Q>		Quit
<Home>		Move to first commit
<End>		Move to last commit
<Up>, p, i	Move up one commit
<Down>, n, k	Move down one commit
<Left>, z, j	Go back in history list
<Right>, x, l	Go forward in history list
<PageUp>	Move up one page in commit list
<PageDown>	Move down one page in commit list
<Ctrl-Home>	Scroll to top of commit list
<Ctrl-End>	Scroll to bottom of commit list
<Ctrl-Up>	Scroll commit list up one line
<Ctrl-Down>	Scroll commit list down one line
<Ctrl-PageUp>	Scroll commit list up one page
<Ctrl-PageDown>	Scroll commit list down one page
<Shift-Up>	Move to previous highlighted line
<Shift-Down>	Move to next highlighted line
<Delete>, b	Scroll diff view up one page
<Backspace>	Scroll diff view up one page
<Space>		Scroll diff view down one page
u		Scroll diff view up 18 lines
d		Scroll diff view down 18 lines
<Ctrl-F>		Find
<Ctrl-G>		Move to next find hit
<Return>	Move to next find hit
/		Move to next find hit, or redo find
?		Move to previous find hit
f		Scroll diff view to next file
<Ctrl-S>		Search for next hit in diff view
<Ctrl-R>		Search for previous hit in diff view
<Ctrl-KP+>	Increase font size
<Ctrl-plus>	Increase font size
<Ctrl-KP->	Decrease font size
<Ctrl-minus>	Decrease font size
} \
	    -justify left -bg white -border 2 -relief sunken
    pack $w.m -side top -fill both
    button $w.ok -text Close -command "destroy $w"
    pack $w.ok -side bottom
}

# Procedures for manipulating the file list window at the
# bottom right of the overall window.

proc treeview {w l openlevs} {
    global treecontents treediropen treeheight treeparent treeindex

    set ix 0
    set treeindex() 0
    set lev 0
    set prefix {}
    set prefixend -1
    set prefendstack {}
    set htstack {}
    set ht 0
    set treecontents() {}
    $w conf -state normal
    foreach f $l {
	while {[string range $f 0 $prefixend] ne $prefix} {
	    if {$lev <= $openlevs} {
		$w mark set e:$treeindex($prefix) "end -1c"
		$w mark gravity e:$treeindex($prefix) left
	    }
	    set treeheight($prefix) $ht
	    incr ht [lindex $htstack end]
	    set htstack [lreplace $htstack end end]
	    set prefixend [lindex $prefendstack end]
	    set prefendstack [lreplace $prefendstack end end]
	    set prefix [string range $prefix 0 $prefixend]
	    incr lev -1
	}
	set tail [string range $f [expr {$prefixend+1}] end]
	while {[set slash [string first "/" $tail]] >= 0} {
	    lappend htstack $ht
	    set ht 0
	    lappend prefendstack $prefixend
	    incr prefixend [expr {$slash + 1}]
	    set d [string range $tail 0 $slash]
	    lappend treecontents($prefix) $d
	    set oldprefix $prefix
	    append prefix $d
	    set treecontents($prefix) {}
	    set treeindex($prefix) [incr ix]
	    set treeparent($prefix) $oldprefix
	    set tail [string range $tail [expr {$slash+1}] end]
	    if {$lev <= $openlevs} {
		set ht 1
		set treediropen($prefix) [expr {$lev < $openlevs}]
		set bm [expr {$lev == $openlevs? "tri-rt": "tri-dn"}]
		$w mark set d:$ix "end -1c"
		$w mark gravity d:$ix left
		set str "\n"
		for {set i 0} {$i < $lev} {incr i} {append str "\t"}
		$w insert end $str
		$w image create end -align center -image $bm -padx 1 \
		    -name a:$ix
		$w insert end $d [highlight_tag $prefix]
		$w mark set s:$ix "end -1c"
		$w mark gravity s:$ix left
	    }
	    incr lev
	}
	if {$tail ne {}} {
	    if {$lev <= $openlevs} {
		incr ht
		set str "\n"
		for {set i 0} {$i < $lev} {incr i} {append str "\t"}
		$w insert end $str
		$w insert end $tail [highlight_tag $f]
	    }
	    lappend treecontents($prefix) $tail
	}
    }
    while {$htstack ne {}} {
	set treeheight($prefix) $ht
	incr ht [lindex $htstack end]
	set htstack [lreplace $htstack end end]
    }
    $w conf -state disabled
}

proc linetoelt {l} {
    global treeheight treecontents

    set y 2
    set prefix {}
    while {1} {
	foreach e $treecontents($prefix) {
	    if {$y == $l} {
		return "$prefix$e"
	    }
	    set n 1
	    if {[string index $e end] eq "/"} {
		set n $treeheight($prefix$e)
		if {$y + $n > $l} {
		    append prefix $e
		    incr y
		    break
		}
	    }
	    incr y $n
	}
    }
}

proc highlight_tree {y prefix} {
    global treeheight treecontents cflist

    foreach e $treecontents($prefix) {
	set path $prefix$e
	if {[highlight_tag $path] ne {}} {
	    $cflist tag add bold $y.0 "$y.0 lineend"
	}
	incr y
	if {[string index $e end] eq "/" && $treeheight($path) > 1} {
	    set y [highlight_tree $y $path]
	}
    }
    return $y
}

proc treeclosedir {w dir} {
    global treediropen treeheight treeparent treeindex

    set ix $treeindex($dir)
    $w conf -state normal
    $w delete s:$ix e:$ix
    set treediropen($dir) 0
    $w image configure a:$ix -image tri-rt
    $w conf -state disabled
    set n [expr {1 - $treeheight($dir)}]
    while {$dir ne {}} {
	incr treeheight($dir) $n
	set dir $treeparent($dir)
    }
}

proc treeopendir {w dir} {
    global treediropen treeheight treeparent treecontents treeindex

    set ix $treeindex($dir)
    $w conf -state normal
    $w image configure a:$ix -image tri-dn
    $w mark set e:$ix s:$ix
    $w mark gravity e:$ix right
    set lev 0
    set str "\n"
    set n [llength $treecontents($dir)]
    for {set x $dir} {$x ne {}} {set x $treeparent($x)} {
	incr lev
	append str "\t"
	incr treeheight($x) $n
    }
    foreach e $treecontents($dir) {
	set de $dir$e
	if {[string index $e end] eq "/"} {
	    set iy $treeindex($de)
	    $w mark set d:$iy e:$ix
	    $w mark gravity d:$iy left
	    $w insert e:$ix $str
	    set treediropen($de) 0
	    $w image create e:$ix -align center -image tri-rt -padx 1 \
		-name a:$iy
	    $w insert e:$ix $e [highlight_tag $de]
	    $w mark set s:$iy e:$ix
	    $w mark gravity s:$iy left
	    set treeheight($de) 1
	} else {
	    $w insert e:$ix $str
	    $w insert e:$ix $e [highlight_tag $de]
	}
    }
    $w mark gravity e:$ix left
    $w conf -state disabled
    set treediropen($dir) 1
    set top [lindex [split [$w index @0,0] .] 0]
    set ht [$w cget -height]
    set l [lindex [split [$w index s:$ix] .] 0]
    if {$l < $top} {
	$w yview $l.0
    } elseif {$l + $n + 1 > $top + $ht} {
	set top [expr {$l + $n + 2 - $ht}]
	if {$l < $top} {
	    set top $l
	}
	$w yview $top.0
    }
}

proc treeclick {w x y} {
    global treediropen cmitmode ctext cflist cflist_top

    if {$cmitmode ne "tree"} return
    if {![info exists cflist_top]} return
    set l [lindex [split [$w index "@$x,$y"] "."] 0]
    $cflist tag remove highlight $cflist_top.0 "$cflist_top.0 lineend"
    $cflist tag add highlight $l.0 "$l.0 lineend"
    set cflist_top $l
    if {$l == 1} {
	$ctext yview 1.0
	return
    }
    set e [linetoelt $l]
    if {[string index $e end] ne "/"} {
	showfile $e
    } elseif {$treediropen($e)} {
	treeclosedir $w $e
    } else {
	treeopendir $w $e
    }
}

proc setfilelist {id} {
    global treefilelist cflist

    treeview $cflist $treefilelist($id) 0
}

image create bitmap tri-rt -background black -foreground blue -data {
    #define tri-rt_width 13
    #define tri-rt_height 13
    static unsigned char tri-rt_bits[] = {
       0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x30, 0x00, 0x70, 0x00, 0xf0, 0x00,
       0xf0, 0x01, 0xf0, 0x00, 0x70, 0x00, 0x30, 0x00, 0x10, 0x00, 0x00, 0x00,
       0x00, 0x00};
} -maskdata {
    #define tri-rt-mask_width 13
    #define tri-rt-mask_height 13
    static unsigned char tri-rt-mask_bits[] = {
       0x08, 0x00, 0x18, 0x00, 0x38, 0x00, 0x78, 0x00, 0xf8, 0x00, 0xf8, 0x01,
       0xf8, 0x03, 0xf8, 0x01, 0xf8, 0x00, 0x78, 0x00, 0x38, 0x00, 0x18, 0x00,
       0x08, 0x00};
}
image create bitmap tri-dn -background black -foreground blue -data {
    #define tri-dn_width 13
    #define tri-dn_height 13
    static unsigned char tri-dn_bits[] = {
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x07, 0xf8, 0x03,
       0xf0, 0x01, 0xe0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00};
} -maskdata {
    #define tri-dn-mask_width 13
    #define tri-dn-mask_height 13
    static unsigned char tri-dn-mask_bits[] = {
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x1f, 0xfe, 0x0f, 0xfc, 0x07,
       0xf8, 0x03, 0xf0, 0x01, 0xe0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00};
}

proc init_flist {first} {
    global cflist cflist_top selectedline difffilestart

    $cflist conf -state normal
    $cflist delete 0.0 end
    if {$first ne {}} {
	$cflist insert end $first
	set cflist_top 1
	$cflist tag add highlight 1.0 "1.0 lineend"
    } else {
	catch {unset cflist_top}
    }
    $cflist conf -state disabled
    set difffilestart {}
}

proc highlight_tag {f} {
    global highlight_paths

    foreach p $highlight_paths {
	if {[string match $p $f]} {
	    return "bold"
	}
    }
    return {}
}

proc highlight_filelist {} {
    global cmitmode cflist

    $cflist conf -state normal
    if {$cmitmode ne "tree"} {
	set end [lindex [split [$cflist index end] .] 0]
	for {set l 2} {$l < $end} {incr l} {
	    set line [$cflist get $l.0 "$l.0 lineend"]
	    if {[highlight_tag $line] ne {}} {
		$cflist tag add bold $l.0 "$l.0 lineend"
	    }
	}
    } else {
	highlight_tree 2 {}
    }
    $cflist conf -state disabled
}

proc unhighlight_filelist {} {
    global cflist

    $cflist conf -state normal
    $cflist tag remove bold 1.0 end
    $cflist conf -state disabled
}

proc add_flist {fl} {
    global cflist

    $cflist conf -state normal
    foreach f $fl {
	$cflist insert end "\n"
	$cflist insert end $f [highlight_tag $f]
    }
    $cflist conf -state disabled
}

proc sel_flist {w x y} {
    global ctext difffilestart cflist cflist_top cmitmode

    if {$cmitmode eq "tree"} return
    if {![info exists cflist_top]} return
    set l [lindex [split [$w index "@$x,$y"] "."] 0]
    $cflist tag remove highlight $cflist_top.0 "$cflist_top.0 lineend"
    $cflist tag add highlight $l.0 "$l.0 lineend"
    set cflist_top $l
    if {$l == 1} {
	$ctext yview 1.0
    } else {
	catch {$ctext yview [lindex $difffilestart [expr {$l - 2}]]}
    }
}

# Functions for adding and removing shell-type quoting

proc shellquote {str} {
    if {![string match "*\['\"\\ \t]*" $str]} {
	return $str
    }
    if {![string match "*\['\"\\]*" $str]} {
	return "\"$str\""
    }
    if {![string match "*'*" $str]} {
	return "'$str'"
    }
    return "\"[string map {\" \\\" \\ \\\\} $str]\""
}

proc shellarglist {l} {
    set str {}
    foreach a $l {
	if {$str ne {}} {
	    append str " "
	}
	append str [shellquote $a]
    }
    return $str
}

proc shelldequote {str} {
    set ret {}
    set used -1
    while {1} {
	incr used
	if {![regexp -start $used -indices "\['\"\\\\ \t]" $str first]} {
	    append ret [string range $str $used end]
	    set used [string length $str]
	    break
	}
	set first [lindex $first 0]
	set ch [string index $str $first]
	if {$first > $used} {
	    append ret [string range $str $used [expr {$first - 1}]]
	    set used $first
	}
	if {$ch eq " " || $ch eq "\t"} break
	incr used
	if {$ch eq "'"} {
	    set first [string first "'" $str $used]
	    if {$first < 0} {
		error "unmatched single-quote"
	    }
	    append ret [string range $str $used [expr {$first - 1}]]
	    set used $first
	    continue
	}
	if {$ch eq "\\"} {
	    if {$used >= [string length $str]} {
		error "trailing backslash"
	    }
	    append ret [string index $str $used]
	    continue
	}
	# here ch == "\""
	while {1} {
	    if {![regexp -start $used -indices "\[\"\\\\]" $str first]} {
		error "unmatched double-quote"
	    }
	    set first [lindex $first 0]
	    set ch [string index $str $first]
	    if {$first > $used} {
		append ret [string range $str $used [expr {$first - 1}]]
		set used $first
	    }
	    if {$ch eq "\""} break
	    incr used
	    append ret [string index $str $used]
	    incr used
	}
    }
    return [list $used $ret]
}

proc shellsplit {str} {
    set l {}
    while {1} {
	set str [string trimleft $str]
	if {$str eq {}} break
	set dq [shelldequote $str]
	set n [lindex $dq 0]
	set word [lindex $dq 1]
	set str [string range $str $n end]
	lappend l $word
    }
    return $l
}

# Code to implement multiple views

proc newview {ishighlight} {
    global nextviewnum newviewname newviewperm uifont newishighlight
    global newviewargs revtreeargs

    set newishighlight $ishighlight
    set top .gitkview
    if {[winfo exists $top]} {
	raise $top
	return
    }
    set newviewname($nextviewnum) "View $nextviewnum"
    set newviewperm($nextviewnum) 0
    set newviewargs($nextviewnum) [shellarglist $revtreeargs]
    vieweditor $top $nextviewnum "Gitk view definition" 
}

proc editview {} {
    global curview
    global viewperm newviewname newviewperm newviewargs

    set top .gitkvedit-$curview
    if {[winfo exists $top]} {
	raise $top
	return
    }
    set newviewname($curview) [tsv::get viewname $curview]
    set newviewperm($curview) $viewperm($curview)
    set newviewargs($curview) [shellarglist [tsv::get viewargs $curview]]
    vieweditor $top $curview "Gitk: edit view $newviewname($curview)"
}

proc vieweditor {top n title} {
    global newviewperm
    global uifont

    toplevel $top
    wm title $top $title
    label $top.nl -text "Name" -font $uifont
    entry $top.name -width 20 -textvariable newviewname($n)
    grid $top.nl $top.name -sticky w -pady 5
    checkbutton $top.perm -text "Remember this view" -variable newviewperm($n)
    grid $top.perm - -pady 5 -sticky w
    message $top.al -aspect 1000 -font $uifont \
	-text "Commits to include (arguments to git rev-list):"
    grid $top.al - -sticky w -pady 5
    entry $top.args -width 50 -textvariable newviewargs($n) \
	-background white
    grid $top.args - -sticky ew -padx 5
    message $top.l -aspect 1000 -font $uifont \
	-text "Enter files and directories to include, one per line:"
    grid $top.l - -sticky w
    text $top.t -width 40 -height 10 -background white
    if {[tsv::exists viewfiles $n]} {
	foreach f [tsv::get viewfiles $n] {
	    $top.t insert end $f
	    $top.t insert end "\n"
	}
	$top.t delete {end - 1c} end
	$top.t mark set insert 0.0
    }
    grid $top.t - -sticky ew -padx 5
    frame $top.buts
    button $top.buts.ok -text "OK" -command [list newviewok $top $n]
    button $top.buts.can -text "Cancel" -command [list destroy $top]
    grid $top.buts.ok $top.buts.can
    grid columnconfigure $top.buts 0 -weight 1 -uniform a
    grid columnconfigure $top.buts 1 -weight 1 -uniform a
    grid $top.buts - -pady 10 -sticky ew
    focus $top.t
}

proc doviewmenu {m first cmd op argv} {
    set nmenu [$m index end]
    for {set i $first} {$i <= $nmenu} {incr i} {
	if {[$m entrycget $i -command] eq $cmd} {
	    eval $m $op $i $argv
	    break
	}
    }
}

proc allviewmenus {n op args} {
    global viewhlmenu

    doviewmenu .bar.view 7 [list showview $n] $op $args
    doviewmenu $viewhlmenu 1 [list addvhighlight $n] $op $args
}

proc newviewok {top n} {
    global nextviewnum newviewperm newviewname newishighlight
    global viewperm selectedview curview
    global newviewargs viewhlmenu

    if {[catch {
	set newargs [shellsplit $newviewargs($n)]
    } err]} {
	error_popup "Error in commit selection arguments: $err"
	wm raise $top
	focus $top
	return
    }
    set files {}
    foreach f [split [$top.t get 0.0 end] "\n"] {
	set ft [string trim $f]
	if {$ft ne {}} {
	    lappend files $ft
	}
    }
    if {![tsv::exists viewfiles $n]} {
	# creating a new view
	incr nextviewnum
	tsv::set viewname $n $newviewname($n)
	set viewperm($n) $newviewperm($n)
	tsv::set viewfiles $n $files
	tsv::set viewargs $n $newargs
	addviewmenu $n
	if {!$newishighlight} {
	    run showview $n
	} else {
	    run addvhighlight $n
	}
    } else {
	# editing an existing view
	set viewperm($n) $newviewperm($n)
	if {$newviewname($n) ne [tsv::get viewname $n]} {
	    tsv::set viewname $n $newviewname($n)
	    doviewmenu .bar.view 7 [list showview $n] \
		entryconf [list -label $newviewname($n)]
	    doviewmenu $viewhlmenu 1 [list addvhighlight $n] \
		entryconf [list -label $newviewname($n) \
			       -value $newviewname($n)]
	}
	if {$files ne [tsv::get viewfiles $n] ||
	    $newargs ne [tsv::get viewargs $n]} {
	    tsv::set viewfiles $n $files
	    tsv::set viewargs $n $newargs
	    if {$curview == $n} {
		run reloadcommits
	    }
	}
    }
    catch {destroy $top}
}

proc delview {} {
    global curview viewperm hlview selectedhlview

    if {$curview == 0} return
    if {[info exists hlview] && $hlview == $curview} {
	set selectedhlview None
	unset hlview
    }
    allviewmenus $curview delete
    set viewperm($curview) 0
    showview 0
}

proc addviewmenu {n} {
    global viewhlmenu

    .bar.view add radiobutton -label [tsv::get viewname $n] \
	-command [list showview $n] -variable selectedview -value $n
    $viewhlmenu add radiobutton -label [tsv::get viewname $n] \
	-command [list addvhighlight $n] -variable selectedhlview
}

proc showview {n} {
    global curview viewstate
    global colormap rowtextx nextcolor canvxmax
    global numcommits vncommits vphase
    global selectedline currentid canv canvy0
    global matchinglines treediffs
    global pending_select phase
    global selectedview nullid selectfirst
    global hlview selectedhlview

    if {$n == $curview} return
    set selid {}
    set yscreen 0
    if {[info exists selectedline]} {
	set selid $currentid
	set y [yc $selectedline]
	set ymax [lindex [$canv cget -scrollregion] 3]
	set span [$canv yview]
	set ytop [expr {[lindex $span 0] * $ymax}]
	set ybot [expr {[lindex $span 1] * $ymax}]
	if {$ytop < $y && $y < $ybot} {
	    set yscreen [expr {$y - $ytop}]
	} else {
	    set yscreen [expr {($ybot - $ytop) / 2}]
	}
    } elseif {[info exists pending_select]} {
	set selid $pending_select
	unset pending_select
    }
    unselectline
    normalline
    stopfindproc

    set vncommits($curview) $numcommits
    set vphase($curview) $phase

    catch {unset matchinglines}
    catch {unset treediffs}
    clear_display
    if {[info exists hlview] && $hlview == $n} {
	unset hlview
	set selectedhlview None
    }

    set selectedview $n
    .bar.view entryconf 2 -state [expr {$n == 0? "disabled": "normal"}]
    .bar.view entryconf 3 -state [expr {$n == 0? "disabled": "normal"}]

    if {$selid ne {}} {
	set pending_select $selid
    }

    if {![info exists viewstate($n)]} {
	getcommits $n
	return
    }

    do_layout switch_view $n
    set curview $n

    if {![info exists vphase($n)]} {
	nowbusy layout
	set phase getcommits
	init_screen
	show_status "Reading commits..."
	return
    }

    set phase $vphase($n)
    set numcommits $vncommits($n)

    catch {unset colormap}
    catch {unset rowtextx}
    set nextcolor 0
    set canvxmax [$canv cget -width]
    setcanvscroll

    if {$numcommits == 0} {
	if {$phase ne {}} {
	    if {$phase eq "getcommits"} {
		show_status "Reading commits..."
	    }
	} else {
	    show_status "No commits selected"
	}
	return
    }

    set yf 0
    set row {}
    set selectfirst 0
    if {$selid ne {}} {
	set row [rowofcommit $n $selid]
	# try to get the selected row in the same position on the screen
	if {$row ne {} && $row < $numcommits} {
	    set ymax [lindex [$canv cget -scrollregion] 3]
	    set ytop [expr {[yc $row] - $yscreen}]
	    if {$ytop < 0} {
		set ytop 0
	    }
	    set yf [expr {$ytop * 1.0 / $ymax}]
	}
    }
    allcanvs yview moveto $yf
    drawvisible
    if {$row ne {} && $row < $numcommits} {
	selectline $row 0
    } elseif {$selid eq {}} {
	set row [expr {[tsv::lindex disporder $curview 0] eq $nullid}]
	if {$row < $numcommits} {
	    selectline $row 0
	} else {
	    set selectfirst 1
	}
    }
}

# Stuff relating to the highlighting facility

proc ishighlighted {row} {
    global vhighlights fhighlights nhighlights rhighlights

    if {[info exists nhighlights($row)] && $nhighlights($row) > 0} {
	return $nhighlights($row)
    }
    if {[info exists vhighlights($row)] && $vhighlights($row) > 0} {
	return $vhighlights($row)
    }
    if {[info exists fhighlights($row)] && $fhighlights($row) > 0} {
	return $fhighlights($row)
    }
    if {[info exists rhighlights($row)] && $rhighlights($row) > 0} {
	return $rhighlights($row)
    }
    return 0
}

proc bolden {row font} {
    global canv linehtag selectedline boldrows

    lappend boldrows $row
    $canv itemconf $linehtag($row) -font $font
    if {[info exists selectedline] && $row == $selectedline} {
	$canv delete secsel
	set t [eval $canv create rect [$canv bbox $linehtag($row)] \
		   -outline {{}} -tags secsel \
		   -fill [$canv cget -selectbackground]]
	$canv lower $t
    }
}

proc bolden_name {row font} {
    global canv2 linentag selectedline boldnamerows

    lappend boldnamerows $row
    $canv2 itemconf $linentag($row) -font $font
    if {[info exists selectedline] && $row == $selectedline} {
	$canv2 delete secsel
	set t [eval $canv2 create rect [$canv2 bbox $linentag($row)] \
		   -outline {{}} -tags secsel \
		   -fill [$canv2 cget -selectbackground]]
	$canv2 lower $t
    }
}

proc unbolden {} {
    global mainfont boldrows

    set stillbold {}
    foreach row $boldrows {
	if {![ishighlighted $row]} {
	    bolden $row $mainfont
	} else {
	    lappend stillbold $row
	}
    }
    set boldrows $stillbold
}

proc addvhighlight {n} {
    global hlview curview vhl_done viewstate

    if {[info exists hlview]} {
	delvhighlight
    }
    set hlview $n
    if {![info exists viewstate($n)]} {
	read_revs $view
    }
    if {[tsv::exists disporder $n]} {
	set vhl_done [tsv::llength disporder $n]
	if {$vhl_done > 0} {
	    drawvisible
	}
    } else {
	set vhl_done 0
    }
}

proc delvhighlight {} {
    global hlview vhighlights

    if {![info exists hlview]} return
    unset hlview
    catch {unset vhighlights}
    unbolden
}

proc vhighlightmore {max} {
    global hlview vhl_done vhighlights
    global curview mainfont

    set font [concat $mainfont bold]
    set vr [visiblerows]
    set r0 [lindex $vr 0]
    set r1 [lindex $vr 1]
    for {set i $vhl_done} {$i < $max} {incr i} {
	set id [tsv::lindex disporder $hlview $i]
	set row [rowofcommit $curview $id]
	if {$row ne {}} {
	    if {$r0 <= $row && $row <= $r1} {
		if {![highlighted $row]} {
		    bolden $row $font
		}
		set vhighlights($row) 1
	    }
	}
    }
    set vhl_done $max
}

proc askvhighlight {row id} {
    global hlview vhighlights iddrawn mainfont

    if {[tsv::exists ctok$hlview $id]} {
	if {[info exists iddrawn($id)] && ![ishighlighted $row]} {
	    bolden $row [concat $mainfont bold]
	}
	set vhighlights($row) 1
    } else {
	set vhighlights($row) 0
    }
}

proc hfiles_change {name ix op} {
    global highlight_files filehighlight fhighlights fh_serial
    global mainfont highlight_paths

    if {[info exists filehighlight]} {
	# delete previous highlights
	catch {close $filehighlight}
	unset filehighlight
	catch {unset fhighlights}
	unbolden
	unhighlight_filelist
    }
    set highlight_paths {}
    after cancel do_file_hl $fh_serial
    incr fh_serial
    if {$highlight_files ne {}} {
	after 300 do_file_hl $fh_serial
    }
}

proc makepatterns {l} {
    set ret {}
    foreach e $l {
	set ee [string map {"*" "\\*" "?" "\\?" "\[" "\\\[" "\\" "\\\\"} $e]
	if {[string index $ee end] eq "/"} {
	    lappend ret "$ee*"
	} else {
	    lappend ret $ee
	    lappend ret "$ee/*"
	}
    }
    return $ret
}

proc do_file_hl {serial} {
    global highlight_files filehighlight highlight_paths gdttype fhl_list

    if {$gdttype eq "touching paths:"} {
	if {[catch {set paths [shellsplit $highlight_files]}]} return
	set highlight_paths [makepatterns $paths]
	highlight_filelist
	set gdtargs [concat -- $paths]
    } else {
	set gdtargs [list "-S$highlight_files"]
    }
    set cmd [concat | git-diff-tree -r -s --stdin $gdtargs]
    set filehighlight [open $cmd r+]
    fconfigure $filehighlight -blocking 0
    filerun $filehighlight readfhighlight
    set fhl_list {}
    drawvisible
    flushhighlights
}

proc flushhighlights {} {
    global filehighlight fhl_list

    if {[info exists filehighlight]} {
	lappend fhl_list {}
	puts $filehighlight ""
	flush $filehighlight
    }
}

proc askfilehighlight {row id} {
    global filehighlight fhighlights fhl_list

    lappend fhl_list $id
    set fhighlights($row) -1
    puts $filehighlight $id
}

proc readfhighlight {} {
    global filehighlight fhighlights curview mainfont iddrawn
    global fhl_list

    if {![info exists filehighlight]} {
	return 0
    }
    set nr 0
    while {[incr nr] <= 100 && [gets $filehighlight line] >= 0} {
	set line [string trim $line]
	set i [lsearch -exact $fhl_list $line]
	if {$i < 0} continue
	for {set j 0} {$j < $i} {incr j} {
	    set id [lindex $fhl_list $j]
	    set row [rowofcommit $curview $id]
	    if {$row ne {}} {
		set fhighlights($row) 0
	    }
	}
	set fhl_list [lrange $fhl_list [expr {$i+1}] end]
	if {$line eq {}} continue
	set row [rowofcommit $curview $line]
	if {$row eq {}} continue
	if {[info exists iddrawn($line)] && ![ishighlighted $row]} {
	    bolden $row [concat $mainfont bold]
	}
	set fhighlights($row) 1
    }
    if {[eof $filehighlight]} {
	# strange...
	puts "oops, git-diff-tree died"
	catch {close $filehighlight}
	unset filehighlight
	return 0
    }
    next_hlcont
    return 1
}

proc find_change {name ix op} {
    global nhighlights mainfont boldnamerows
    global findstring findpattern findtype

    # delete previous highlights, if any
    foreach row $boldnamerows {
	bolden_name $row $mainfont
    }
    set boldnamerows {}
    catch {unset nhighlights}
    unbolden
    if {$findtype ne "Regexp"} {
	set e [string map {"*" "\\*" "?" "\\?" "\[" "\\\[" "\\" "\\\\"} \
		   $findstring]
	set findpattern "*$e*"
    }
    drawvisible
}

proc askfindhighlight {row id} {
    global nhighlights iddrawn mainfont
    global findstring findtype findloc findpattern

    if {![tsv::exists commitinfo $id]} {
	getcommit $id
    }
    set info [tsv::get commitinfo $id]
    set isbold 0
    set fldtypes {Headline Author Date Committer CDate Comments}
    foreach f $info ty $fldtypes {
	if {$findloc ne "All fields" && $findloc ne $ty} {
	    continue
	}
	if {$findtype eq "Regexp"} {
	    set doesmatch [regexp $findstring $f]
	} elseif {$findtype eq "IgnCase"} {
	    set doesmatch [string match -nocase $findpattern $f]
	} else {
	    set doesmatch [string match $findpattern $f]
	}
	if {$doesmatch} {
	    if {$ty eq "Author"} {
		set isbold 2
	    } else {
		set isbold 1
	    }
	}
    }
    if {[info exists iddrawn($id)]} {
	if {$isbold && ![ishighlighted $row]} {
	    bolden $row [concat $mainfont bold]
	}
	if {$isbold >= 2} {
	    bolden_name $row [concat $mainfont bold]
	}
    }
    set nhighlights($row) $isbold
}

proc vrel_change {name ix op} {
    global highlight_related

    rhighlight_none
    if {$highlight_related ne "None"} {
	run drawvisible
    }
}

# prepare for testing whether commits are descendents or ancestors of a
proc rhighlight_sel {a} {
    global descendent desc_todo ancestor anc_todo
    global highlight_related rhighlights

    catch {unset descendent}
    set desc_todo [list $a]
    catch {unset ancestor}
    set anc_todo [list $a]
    if {$highlight_related ne "None"} {
	rhighlight_none
	run drawvisible
    }
}

proc rhighlight_none {} {
    global rhighlights

    catch {unset rhighlights}
    unbolden
}

proc is_descendent {a} {
    global curview descendent desc_todo

    set v $curview
    set toka [tsv::get ctok$v $a]
    set todo $desc_todo
    set leftover {}
    set done 0
    for {set i 0} {$i < [llength $todo]} {incr i} {
	set do [lindex $todo $i]
	if {[tokencmp [tsv::get ctok$v $do] $toka] < 0} {
	    lappend leftover $do
	    continue
	}
	foreach nk [tsv::get children$v $do] {
	    if {![info exists descendent($nk)]} {
		set descendent($nk) 1
		lappend todo $nk
		if {$nk eq $a} {
		    set done 1
		}
	    }
	}
	if {$done} {
	    set desc_todo [concat $leftover [lrange $todo [expr {$i+1}] end]]
	    return
	}
    }
    set descendent($a) 0
    set desc_todo $leftover
}

proc is_ancestor {a} {
    global curview ancestor anc_todo

    set v $curview
    set toka [tsv::get ctok$v $a]
    set todo $anc_todo
    set leftover {}
    set done 0
    for {set i 0} {$i < [llength $todo]} {incr i} {
	set do [lindex $todo $i]
	if {![tsv::exists ctok$v $do] ||
	    [tokencmp [tsv::get ctok$v $do] $toka] > 0} {
	    lappend leftover $do
	    continue
	}
	foreach np [tsv::get parents$v $do] {
	    if {![info exists ancestor($np)]} {
		set ancestor($np) 1
		lappend todo $np
		if {$np eq $a} {
		    set done 1
		}
	    }
	}
	if {$done} {
	    set anc_todo [concat $leftover [lrange $todo [expr {$i+1}] end]]
	    return
	}
    }
    set ancestor($a) 0
    set anc_todo $leftover
}

proc askrelhighlight {row id} {
    global descendent highlight_related iddrawn mainfont rhighlights
    global selectedline ancestor

    if {![info exists selectedline]} return
    set isbold 0
    if {$highlight_related eq "Descendent" ||
	$highlight_related eq "Not descendent"} {
	if {![info exists descendent($id)]} {
	    is_descendent $id
	}
	if {$descendent($id) == ($highlight_related eq "Descendent")} {
	    set isbold 1
	}
    } elseif {$highlight_related eq "Ancestor" ||
	      $highlight_related eq "Not ancestor"} {
	if {![info exists ancestor($id)]} {
	    is_ancestor $id
	}
	if {$ancestor($id) == ($highlight_related eq "Ancestor")} {
	    set isbold 1
	}
    }
    if {[info exists iddrawn($id)]} {
	if {$isbold && ![ishighlighted $row]} {
	    bolden $row [concat $mainfont bold]
	}
    }
    set rhighlights($row) $isbold
}

proc next_hlcont {} {
    global fhl_row fhl_dirn numcommits curview
    global vhighlights fhighlights nhighlights rhighlights
    global hlview filehighlight findstring highlight_related

    if {![info exists fhl_dirn] || $fhl_dirn == 0} return
    set row $fhl_row
    while {1} {
	if {$row < 0 || $row >= $numcommits} {
	    bell
	    set fhl_dirn 0
	    return
	}
	set id [tsv::lindex disporder $curview $row]
	if {[info exists hlview]} {
	    if {![info exists vhighlights($row)]} {
		askvhighlight $row $id
	    }
	    if {$vhighlights($row) > 0} break
	}
	if {$findstring ne {}} {
	    if {![info exists nhighlights($row)]} {
		askfindhighlight $row $id
	    }
	    if {$nhighlights($row) > 0} break
	}
	if {$highlight_related ne "None"} {
	    if {![info exists rhighlights($row)]} {
		askrelhighlight $row $id
	    }
	    if {$rhighlights($row) > 0} break
	}
	if {[info exists filehighlight]} {
	    if {![info exists fhighlights($row)]} {
		# ask for a few more while we're at it...
		set r $row
		for {set n 0} {$n < 100} {incr n} {
		    if {![info exists fhighlights($r)]} {
			askfilehighlight $r [tsv::lindex disporder $curview $r]
		    }
		    incr r $fhl_dirn
		    if {$r < 0 || $r >= $numcommits} break
		}
		flushhighlights
	    }
	    if {$fhighlights($row) < 0} {
		set fhl_row $row
		return
	    }
	    if {$fhighlights($row) > 0} break
	}
	incr row $fhl_dirn
    }
    set fhl_dirn 0
    selectline $row 1
}

proc next_highlight {dirn} {
    global selectedline fhl_row fhl_dirn
    global hlview filehighlight findstring highlight_related

    if {![info exists selectedline]} return
    if {!([info exists hlview] || $findstring ne {} ||
	  $highlight_related ne "None" || [info exists filehighlight])} return
    set fhl_row [expr {$selectedline + $dirn}]
    set fhl_dirn $dirn
    next_hlcont
}

proc cancel_next_highlight {} {
    global fhl_dirn

    set fhl_dirn 0
}

# Graph display functions

proc init_screen {} {
    global numcommits canvxmax canv
    global nextcolor colormap rowtextx
    global selectfirst

    set numcommits 0
    set nextcolor 0
    set canvxmax [$canv cget -width]
    catch {unset colormap}
    catch {unset rowtextx}
    set selectfirst 1
}

proc setcanvscroll {} {
    global canv canv2 canv3 numcommits linespc canvxmax canvy0

    set ymax [expr {$canvy0 + ($numcommits - 0.5) * $linespc + 2}]
    $canv conf -scrollregion [list 0 0 $canvxmax $ymax]
    $canv2 conf -scrollregion [list 0 0 0 $ymax]
    $canv3 conf -scrollregion [list 0 0 0 $ymax]
}

proc newcommits {view nrows gen} {
    global hlview viewgen

    if {[info exists hlview] && $view == $hlview && $viewgen($view) == $gen} {
	vhighlightmore $nrows
    }
}

proc truncatecommits {view nrows gen} {
    global curview hlview vhl_done viewgen

    if {$viewgen($view) != $gen} return
    if {$view == $curview} {
	trim_display $nrows
    }
    if {[info exists hlview] && $view == $hlview && $nrows <= $vhl_done} {
	set vhl_done [expr {$nrows - 1}]
    }
}

proc trim_display {nlines} {
    global numcommits selectedline

    if {$nlines < $numcommits} {
	set numcommits $nlines
	setcanvscroll
    }
    if {[info exists selectedline] && $selectedline >= $nlines} {
	unselectline
    }
}

proc visiblerows {} {
    global canv numcommits linespc

    set ymax [lindex [$canv cget -scrollregion] 3]
    if {$ymax eq {} || $ymax == 0} return
    set f [$canv yview]
    set y0 [expr {int([lindex $f 0] * $ymax)}]
    set r0 [expr {int(($y0 - 3) / $linespc) - 1}]
    if {$r0 < 0} {
	set r0 0
    }
    set y1 [expr {int([lindex $f 1] * $ymax)}]
    set r1 [expr {int(($y1 - 3) / $linespc) + 1}]
    if {$r1 >= $numcommits} {
	set r1 [expr {$numcommits - 1}]
    }
    return [list $r0 $r1]
}

# see if `id' is shown on a row before `row'
proc comesbefore {id row} {
    global curview

    return [expr {[tsv::exists ctok$curview $id] &&
		  [tokencmp [tsv::get ctok$curview $id] \
		   [tsv::lindex disporder $curview [expr {$row - 1}]]] <= 0}]
}

proc showstuff {view canshow last gen} {
    global numcommits pending_select selectedline curview
    global lookingforhead mainheadid nullid selectfirst
    global lastscrollset viewgen

    if {$viewgen($view) != $gen} return
    if {$view != $curview} {
	global vncommits
	set vncommits($view) $canshow
	return
    }
    if {$numcommits == 0} {
	global phase
	set phase "incrdraw"
	allcanvs delete all
    }
    set r0 $numcommits
    set prev $numcommits
    set numcommits $canshow
    set t [clock clicks -milliseconds]
    if {$prev < 100 || $last || $t - $lastscrollset > 500} {
	set lastscrollset $t
	setcanvscroll
    }
    set rows [visiblerows]
    set r1 [lindex $rows 1]
    if {$r1 >= $canshow} {
	set r1 [expr {$canshow - 1}]
    }
    if {$r0 <= $r1} {
	drawcommits $r0 $r1
    }
    if {[info exists pending_select] &&
	[comesbefore $pending_select $numcommits]} {
	selectline [rowofcommit $curview $pending_select] 1
    }
    if {$selectfirst} {
	if {[info exists selectedline] || [info exists pending_select]} {
	    set selectfirst 0
	} else {
	    set l [expr {[tsv::lindex disporder $curview 0] eq $nullid}]
	    selectline $l 1
	    set selectfirst 0
	}
    }
    if {$lookingforhead &&
	[tsv::exists ctok$curview $mainheadid] &&
	($last || [comesbefore $mainheadid [expr {$numcommits - 1}]])} {
	set lookingforhead 0
	dodiffindex
    }
    if {$last} {
	if {[info exists pending_select]} {
	    set row [expr {[tsv::lindex disporder $curview 0] eq $nullid}]
	    selectline $row 1
	}
	if {$numcommits == 0} {
	    show_status "No commits selected"
	}
	notbusy layout
	set phase {}
    }
}

proc showmisordered {view gen} {
    global curview viewgen

    if {$view != $curview || $gen != $viewgen($curview)} return
    if {[info exists selectedline]} {
	set pending_select $currentid
	unset selectedline
    }
    # note show_status does clear_display
    show_status "Redoing layout due to misordered commits"
    init_screen
}

proc doshowlocalchanges {} {
    global lookingforhead curview mainheadid phase numcommits

    if {[tsv::exists ctok$curview $mainheadid] &&
	($phase eq {} || [comesbefore $mainheadid [expr {$numcommits - 1}]])} {
	dodiffindex
    } elseif {$phase ne {}} {
	set lookingforhead 1
    }
}

proc dohidelocalchanges {} {
    global lookingforhead localrow lserial

    set lookingforhead 0
    if {$localrow >= 0} {
	removerow $localrow
	set localrow -1
    }
    incr lserial
}

# spawn off a process to do git diff-index HEAD
proc dodiffindex {} {
    global localrow lserial

    incr lserial
    set localrow -1
    set fd [open "|git diff-index HEAD" r]
    fconfigure $fd -blocking 0
    filerun $fd [list readdiffindex $fd $lserial]
}

proc readdiffindex {fd serial} {
    global localrow mainheadid nullid curview
    global lserial

    if {[gets $fd line] < 0} {
	if {[eof $fd]} {
	    close $fd
	    return 0
	}
	return 1
    }
    # we only need to see one line and we don't really care what it says...
    close $fd

    if {$serial == $lserial && $localrow == -1} {
	# add the line for the local diff to the graph
	set localrow [rowofcommit $curview $mainheadid]
	set hl "Local uncommitted changes"
	tsv::set commitinfo $nullid [list  $hl {} {} {} {} "    $hl\n"]
	tsv::set cdata $nullid "\n    $hl\n"
	insertrow $localrow $nullid
    }
    return 0
}

proc xc {row col} {
    global canvx0 linespc
    return [expr {$canvx0 + $col * $linespc}]
}

proc yc {row} {
    global canvy0 linespc
    return [expr {$canvy0 + $row * $linespc}]
}

proc linewidth {id} {
    global thickerline lthickness

    set wid $lthickness
    if {[info exists thickerline] && $id eq $thickerline} {
	set wid [expr {2 * $lthickness}]
    }
    return $wid
}

# work around tk8.4 refusal to draw arrows on diagonal segments
proc adjarrowhigh {coords} {
    global linespc

    set x0 [lindex $coords 0]
    set x1 [lindex $coords 2]
    if {$x0 != $x1} {
	set y0 [lindex $coords 1]
	set y1 [lindex $coords 3]
	if {$y0 - $y1 <= 2 * $linespc && $x1 == [lindex $coords 4]} {
	    # we have a nearby vertical segment, just trim off the diag bit
	    set coords [lrange $coords 2 end]
	} else {
	    set slope [expr {($x0 - $x1) / ($y0 - $y1)}]
	    set xi [expr {$x0 - $slope * $linespc / 2}]
	    set yi [expr {$y0 - $linespc / 2}]
	    set coords [lreplace $coords 0 1 $xi $y0 $xi $yi]
	}
    }
    return $coords
}

set mthreadstuff {
    proc idcolumn {row id} {
	global curview

	return [lsearch -exact [tsv::lindex vrowidlist $curview $row] $id]
    }

    proc getrowids {row} {
	global curview

	return [tsv::lindex vrowidlist $curview $row]
    }

    proc adjust_layout {row inc idlist} {
	global curview

	if {$inc > 0} {
	    tsv::lpush vrowidlist $curview $idlist $row
	} else {
	    tsv::lpop vrowidlist $curview $row
	}
    }
}

set mnotthreadstuff {
    proc idcolumn {row id} {
	global rowidlist

	return [lsearch -exact [lindex $rowidlist $row] $id]
    }

    proc getrowids {row} {
	global rowidlist

	return [lindex $rowidlist $row]
    }

    proc adjust_layout {row inc idlist} {
	global rowlaidout rowoptim lnumcommits curview commitidx
	global rowidlist rowoffsets

	incr rowlaidout $inc
	incr rowoptim $inc
	incr lnumcommits $inc
	incr commitidx($curview) $inc
	if {$inc > 0} {
	    set rowidlist [linsert $rowidlist $row $idlist]
	} else {
	    set rowidlist [lreplace $rowidlist $row $row]
	}
	if {$lnumcommits < $commitidx($curview)} {
	    if {$inc > 0} {
		set rowoffsets [linsert $rowoffsets $row {}]
	    } else {
		set rowoffsets [lreplace $rowoffsets $row $row]
	    }
	}
    }
}

set mstuff {
    proc rowranges {id} {
	global curview
	%ifnotthread% global idrowranges$curview

	set ranges {}
	if {[%tsvexists% idrowranges$curview $id]} {
	    set ranges [%tsvget% idrowranges$curview $id]
	}
	set linenos {}
	foreach rid $ranges {
	    lappend linenos [rowofcommit $curview $rid]
	}
	if {$linenos ne {}} {
	    lset linenos 0 [expr {[lindex $linenos 0] + 1}]
	}
	return $linenos
    }
}

proc drawlineseg {id row endrow arrowlow} {
    global iddrawn linesegs
    global canv colormap linespc curview maxlinelen

    set cols [list [idcolumn $row $id]]
    set le [expr {$row + 1}]
    set arrowhigh 1
    while {1} {
	set c [idcolumn $le $id]
	if {$c < 0} {
	    incr le -1
	    break
	}
	lappend cols $c
	set x [tsv::lindex disporder $curview $le]
	if {$x eq $id} {
	    set arrowhigh 0
	    break
	}
	if {[info exists iddrawn($x)] || $le == $endrow} {
	    set c [idcolumn [expr {$le+1}] $id]
	    if {$c >= 0} {
		lappend cols $c
		set arrowhigh 0
	    }
	    break
	}
	incr le
    }
    if {$le <= $row} {
	return $row
    }
    if {$arrowhigh && [tsv::lsearch idrowranges$curview $id -exact \
			   [tsv::lindex disporder $curview $le]] < 0} {
	set arrowhigh 0
    }

    set lines {}
    set i 0
    set joinhigh 0
    if {[info exists linesegs($id)]} {
	set lines $linesegs($id)
	foreach li $lines {
	    set r0 [lindex $li 0]
	    if {$r0 > $row} {
		if {$r0 == $le && [lindex $li 1] - $row <= $maxlinelen} {
		    set joinhigh 1
		}
		break
	    }
	    incr i
	}
    }
    set joinlow 0
    if {$i > 0} {
	set li [lindex $lines [expr {$i-1}]]
	set r1 [lindex $li 1]
	if {$r1 == $row && $le - [lindex $li 0] <= $maxlinelen} {
	    set joinlow 1
	}
    }

    set x [lindex $cols [expr {$le - $row}]]
    set xp [lindex $cols [expr {$le - 1 - $row}]]
    set dir [expr {$xp - $x}]
    if {$joinhigh} {
	set ith [lindex $lines $i 2]
	set coords [$canv coords $ith]
	set ah [$canv itemcget $ith -arrow]
	set arrowhigh [expr {$ah eq "first" || $ah eq "both"}]
	set x2 [lindex $cols [expr {$le + 1 - $row}]]
	if {$x2 ne {} && $x - $x2 == $dir} {
	    set coords [lrange $coords 0 end-2]
	}
    } else {
	set coords [list [xc $le $x] [yc $le]]
    }
    if {$joinlow} {
	set itl [lindex $lines [expr {$i-1}] 2]
	set al [$canv itemcget $itl -arrow]
	set arrowlow [expr {$al eq "last" || $al eq "both"}]
    } elseif {$arrowlow && [idcolumn [expr {$row-1}] $id] >= 0} {
	set arrowlow 0
    }
    set arrow [lindex {none first last both} [expr {$arrowhigh + 2*$arrowlow}]]
    for {set y $le} {[incr y -1] > $row} {} {
	set x $xp
	set xp [lindex $cols [expr {$y - 1 - $row}]]
	set ndir [expr {$xp - $x}]
	if {$dir != $ndir || $xp < 0} {
	    lappend coords [xc $y $x] [yc $y]
	}
	set dir $ndir
    }
    if {!$joinlow} {
	if {$xp < 0} {
	    # join parent line to first child
	    set ch [tsv::lindex disporder $curview $row]
	    set xc [idcolumn $row $ch]
	    if {$xc < 0} {
		puts "oops: drawlineseg: child $ch not on row $row"
	    } else {
		if {$xc < $x - 1} {
		    lappend coords [xc $row [expr {$x-1}]] [yc $row]
		} elseif {$xc > $x + 1} {
		    lappend coords [xc $row [expr {$x+1}]] [yc $row]
		}
		set x $xc
	    }
	    lappend coords [xc $row $x] [yc $row]
	} else {
	    set xn [xc $row $xp]
	    set yn [yc $row]
	    # work around tk8.4 refusal to draw arrows on diagonal segments
	    if {$arrowlow && $xn != [lindex $coords end-1]} {
		if {[llength $coords] < 4 ||
		    [lindex $coords end-3] != [lindex $coords end-1] ||
		    [lindex $coords end] - $yn > 2 * $linespc} {
		    set xn [xc $row [expr {$xp - 0.5 * $dir}]]
		    set yo [yc [expr {$row + 0.5}]]
		    lappend coords $xn $yo $xn $yn
		}
	    } else {
		lappend coords $xn $yn
	    }
	}
	if {!$joinhigh} {
	    if {$arrowhigh} {
		set coords [adjarrowhigh $coords]
	    }
	    assigncolor $id
	    set t [$canv create line $coords -width [linewidth $id] \
		       -fill $colormap($id) -tags lines.$id -arrow $arrow]
	    $canv lower $t
	    bindline $t $id
	    set lines [linsert $lines $i [list $row $le $t]]
	} else {
	    $canv coords $ith $coords
	    if {$arrow ne $ah} {
		$canv itemconf $ith -arrow $arrow
	    }
	    lset lines $i 0 $row
	}
    } else {
	set xo [idcolumn [expr {$row - 1}] $id]
	set ndir [expr {$xo - $xp}]
	set clow [$canv coords $itl]
	if {$dir == $ndir} {
	    set clow [lrange $clow 2 end]
	}
	set coords [concat $coords $clow]
	if {!$joinhigh} {
	    lset lines [expr {$i-1}] 1 $le
	    if {$arrowhigh} {
		set coords [adjarrowhigh $coords]
	    }
	} else {
	    # coalesce two pieces
	    $canv delete $ith
	    set b [lindex $lines [expr {$i-1}] 0]
	    set e [lindex $lines $i 1]
	    set lines [lreplace $lines [expr {$i-1}] $i [list $b $e $itl]]
	}
	$canv coords $itl $coords
	if {$arrow ne $al} {
	    $canv itemconf $itl -arrow $arrow
	}
    }

    set linesegs($id) $lines
    return $le
}

proc drawparentlinks {id row} {
    global canv colormap curview
    global idpos

    set rowids [getrowids $row]
    set col [lsearch -exact $rowids $id]
    if {$col < 0} return
    set olds [tsv::get parents$curview $id]
    set row2 [expr {$row + 1}]
    set x [xc $row $col]
    set y [yc $row]
    set y2 [yc $row2]
    set ids [getrowids $row2]
    # rmx = right-most X coord used
    set rmx 0
    foreach p $olds {
	set i [lsearch -exact $ids $p]
	if {$i < 0} {
	    puts "oops, parent $p of $id not in list"
	    continue
	}
	set x2 [xc $row2 $i]
	if {$x2 > $rmx} {
	    set rmx $x2
	}
	if {[lsearch -exact $rowids $p] < 0} {
	    # drawlineseg will do this one for us
	    continue
	}
	assigncolor $p
	# should handle duplicated parents here...
	set coords [list $x $y]
	if {$i < $col - 1} {
	    lappend coords [xc $row [expr {$i + 1}]] $y
	} elseif {$i > $col + 1} {
	    lappend coords [xc $row [expr {$i - 1}]] $y
	}
	lappend coords $x2 $y2
	set t [$canv create line $coords -width [linewidth $p] \
		   -fill $colormap($p) -tags lines.$p]
	$canv lower $t
	bindline $t $p
    }
    if {$rmx > [lindex $idpos($id) 1]} {
	lset idpos($id) 1 $rmx
	redrawtags $id
    }
}

proc drawlines {id} {
    global canv

    $canv itemconf lines.$id -width [linewidth $id]
}

proc drawcmittext {id row col} {
    global linespc canv canv2 canv3 canvy0 fgcolor
    global curview
    global rowtextx idpos idotherrefs
    global linehtag linentag linedtag
    global mainfont canvxmax boldrows boldnamerows fgcolor nullid

    if {$id eq $nullid} {
	set ofill red
    } else {
	set ofill [expr {[tsv::lindex vcmitlisted $curview $row]? \
			     "blue": "white"}]
    }
    set x [xc $row $col]
    set y [yc $row]
    set orad [expr {$linespc / 3}]
    set t [$canv create oval [expr {$x - $orad}] [expr {$y - $orad}] \
	       [expr {$x + $orad - 1}] [expr {$y + $orad - 1}] \
	       -fill $ofill -outline $fgcolor -width 1 -tags circle]
    $canv raise $t
    $canv bind $t <1> {selcanvline {} %x %y}
    set rmx [llength [getrowids $row]]
    set olds [tsv::get parents$curview $id]
    if {$olds ne {}} {
	set nextids [getrowids [expr {$row + 1}]]
	foreach p $olds {
	    set i [lsearch -exact $nextids $p]
	    if {$i > $rmx} {
		set rmx $i
	    }
	}
    }
    set xt [xc $row $rmx]
    set rowtextx($row) $xt
    set idpos($id) [list $x $xt $y]
    if {[tsv::exists idtags $id] || [tsv::exists idheads $id]
	|| [info exists idotherrefs($id)]} {
	set xt [drawtags $id $x $xt $y]
    }
    set headline [tsv::lindex commitinfo $id 0]
    set name [tsv::lindex commitinfo $id 1]
    set date [tsv::lindex commitinfo $id 2]
    set date [formatdate $date]
    set font $mainfont
    set nfont $mainfont
    set isbold [ishighlighted $row]
    if {$isbold > 0} {
	lappend boldrows $row
	lappend font bold
	if {$isbold > 1} {
	    lappend boldnamerows $row
	    lappend nfont bold
	}
    }
    set linehtag($row) [$canv create text $xt $y -anchor w -fill $fgcolor \
			    -text $headline -font $font -tags text]
    $canv bind $linehtag($row) <Button-3> "rowmenu %X %Y $id"
    set linentag($row) [$canv2 create text 3 $y -anchor w -fill $fgcolor \
			    -text $name -font $nfont -tags text]
    set linedtag($row) [$canv3 create text 3 $y -anchor w -fill $fgcolor \
			    -text $date -font $mainfont -tags text]
    set xr [expr {$xt + [font measure $mainfont $headline]}]
    if {$xr > $canvxmax} {
	set canvxmax $xr
	setcanvscroll
    }
}

proc askhighlights {row id} {
    global filehighlight fhighlights findstring nhighlights
    global hlview vhighlights
    global highlight_related rhighlights

    if {[info exists hlview] && ![info exists vhighlights($row)]} {
	askvhighlight $row $id
    }
    if {[info exists filehighlight] && ![info exists fhighlights($row)]} {
	askfilehighlight $row $id
    }
    if {$findstring ne {} && ![info exists nhighlights($row)]} {
	askfindhighlight $row $id
    }
    if {$highlight_related ne "None" && ![info exists rhighlights($row)]} {
	askrelhighlight $row $id
    }
}

proc drawcmitrow {row id} {
    global curview

    set col [idcolumn $row $id]
    if {$col < 0} {
	puts "oops, row $row id $id not in list"
	return
    }
    if {![tsv::exists commitinfo $id]} {
	getcommit $id
    }
    assigncolor $id
    drawcmittext $id $row $col
}

proc drawcommits {row {endrow {}}} {
    global numcommits iddrawn curview

    if {$row < 0} {
	set row 0
    }
    if {$endrow eq {}} {
	set endrow $row
    }
    if {$endrow >= $numcommits} {
	set endrow [expr {$numcommits - 1}]
    }

    # make the lines join to already-drawn rows either side
    set r [expr {$row - 1}]
    if {$r < 0 || ![info exists iddrawn([tsv::lindex disporder $curview $r])]} {
	set r $row
    }
    set er [expr {$endrow + 1}]
    if {$er >= $numcommits ||
	![info exists iddrawn([tsv::lindex disporder $curview $er])]} {
	set er $endrow
    }
    for {} {$r <= $er} {incr r} {
	set id [tsv::lindex disporder $curview $r]
	askhighlights $r $id
	set wasdrawn [info exists iddrawn($id)]
	if {!$wasdrawn} {
	    drawcmitrow $r $id
	    set iddrawn($id) 1
	}
	if {$r == $er} break
	set nextid [tsv::lindex disporder $curview [expr {$r + 1}]]
	if {$wasdrawn && [info exists iddrawn($nextid)]} {
	    catch {unset prevlines}
	    continue
	}
	drawparentlinks $id $r

	if {[info exists lineends($r)]} {
	    foreach lid $lineends($r) {
		unset prevlines($lid)
	    }
	}
	set rowids [getrowids $r]
	foreach lid $rowids {
	    if {$lid eq {}} continue
	    if {$lid eq $id} {
		# see if this is the first child of any of its parents
		foreach p [tsv::get parents$curview $id] {
		    if {[lsearch -exact $rowids $p] < 0} {
			# make this line extend up to the child
			set le [drawlineseg $p $r $er 0]
			lappend lineends($le) $p
			set prevlines($p) 1
		    }
		}
	    } elseif {![info exists prevlines($lid)]} {
		set le [drawlineseg $lid $r $er 1]
		lappend lineends($le) $lid
		set prevlines($lid) 1
	    }
	}
    }
}

proc drawfrac {f0 f1} {
    global canv linespc

    set ymax [lindex [$canv cget -scrollregion] 3]
    if {$ymax eq {} || $ymax == 0} return
    set y0 [expr {int($f0 * $ymax)}]
    set row [expr {int(($y0 - 3) / $linespc) - 1}]
    set y1 [expr {int($f1 * $ymax)}]
    set endrow [expr {int(($y1 - 3) / $linespc) + 1}]
    drawcommits $row $endrow
}

proc drawvisible {} {
    global canv
    eval drawfrac [$canv yview]
}

proc clear_display {} {
    global iddrawn linesegs
    global vhighlights fhighlights nhighlights rhighlights

    allcanvs delete all
    catch {unset iddrawn}
    catch {unset linesegs}
    catch {unset vhighlights}
    catch {unset fhighlights}
    catch {unset nhighlights}
    catch {unset rhighlights}
}

proc findcrossings {id} {
    global curview numcommits

    set cross {}
    set ccross {}
    foreach {s e} [rowranges $id] {
	if {$e >= $numcommits} {
	    set e [expr {$numcommits - 1}]
	}
	if {$e <= $s} continue
	for {set row $e} {[incr row -1] >= $s} {} {
	    set x [idcolumn $row $id]
	    if {$x < 0} {
		puts "findcrossings: oops, no [shortids $id] in row $row"
		break
	    }
	    set kid [tsv::lindex disporder $curview $row]
	    set olds [tsv::get parents$curview $kid]
	    set kidx [idcolumn $row $kid]
	    if {$kidx < 0} continue
	    set nextrow [getrowids [expr {$row + 1}]]
	    foreach p $olds {
		set px [lsearch -exact $nextrow $p]
		if {$px < 0} continue
		if {($kidx < $x && $x < $px) || ($px < $x && $x < $kidx)} {
		    if {[lsearch -exact $ccross $p] >= 0} continue
		    if {$x == $px + ($kidx < $px? -1: 1)} {
			lappend ccross $p
		    } elseif {[lsearch -exact $cross $p] < 0} {
			lappend cross $p
		    }
		}
	    }
	}
    }
    return [concat $ccross {{}} $cross]
}

proc assigncolor {id} {
    global colormap colors nextcolor
    global curview

    if {[info exists colormap($id)]} return
    set ncolors [llength $colors]
    set badcolors {}
    if {0} {
	set kids {}
	if {[tsv::exists children$curview $id]} {
	    foreach child [tsv::get children$curview $id] {
		if {[tsv::exists ctok$curview $child]} {
		    lappend kids $child
		}
	    }
	}
	if {[llength $kids] == 1} {
	    set child [lindex $kids 0]
	    if {[info exists colormap($child)]
		&& [llength [tsv::get parents$curview $child]] == 1} {
		set colormap($id) $colormap($child)
		return
	    }
	}
	set badcolors {}
	set origbad {}
	foreach x [findcrossings $id] {
	    if {$x eq {}} {
		# delimiter between corner crossings and other crossings
		if {[llength $badcolors] >= $ncolors - 1} break
		set origbad $badcolors
	    }
	    if {[info exists colormap($x)]
		&& [lsearch -exact $badcolors $colormap($x)] < 0} {
		lappend badcolors $colormap($x)
	    }
	}
	if {[llength $badcolors] >= $ncolors} {
	    set badcolors $origbad
	}
	set origbad $badcolors
	if {[llength $badcolors] < $ncolors - 1} {
	    foreach child $kids {
		if {[info exists colormap($child)]
		    && [lsearch -exact $badcolors $colormap($child)] < 0} {
		    lappend badcolors $colormap($child)
		}
		foreach p [tsv::get parents$curview $child] {
		    if {[info exists colormap($p)]
			&& [lsearch -exact $badcolors $colormap($p)] < 0} {
			lappend badcolors $colormap($p)
		    }
		}
	    }
	    if {[llength $badcolors] >= $ncolors} {
		set badcolors $origbad
	    }
	}
    }
    for {set i 0} {$i <= $ncolors} {incr i} {
	set c [lindex $colors $nextcolor]
	if {[incr nextcolor] >= $ncolors} {
	    set nextcolor 0
	}
	if {[lsearch -exact $badcolors $c]} break
    }
    set colormap($id) $c
}

proc bindline {t id} {
    global canv

    $canv bind $t <Enter> "lineenter %x %y $id"
    $canv bind $t <Motion> "linemotion %x %y $id"
    $canv bind $t <Leave> "lineleave $id"
    $canv bind $t <Button-1> "lineclick %x %y $id 1"
}

proc drawtags {id x xt y1} {
    global idotherrefs mainhead
    global linespc lthickness
    global canv mainfont rowtextx curview fgcolor bgcolor

    set marks {}
    set ntags 0
    set nheads 0
    if {[tsv::exists idtags $id]} {
	set marks [tsv::get idtags $id]
	set ntags [llength $marks]
    }
    if {[tsv::exists idheads $id]} {
	set marks [concat $marks [tsv::get idheads $id]]
	set nheads [tsv::llength idheads $id]
    }
    if {[info exists idotherrefs($id)]} {
	set marks [concat $marks $idotherrefs($id)]
    }
    if {$marks eq {}} {
	return $xt
    }

    set delta [expr {int(0.5 * ($linespc - $lthickness))}]
    set yt [expr {$y1 - 0.5 * $linespc}]
    set yb [expr {$yt + $linespc - 1}]
    set xvals {}
    set wvals {}
    set i -1
    foreach tag $marks {
	incr i
	if {$i >= $ntags && $i < $ntags + $nheads && $tag eq $mainhead} {
	    set wid [font measure [concat $mainfont bold] $tag]
	} else {
	    set wid [font measure $mainfont $tag]
	}
	lappend xvals $xt
	lappend wvals $wid
	set xt [expr {$xt + $delta + $wid + $lthickness + $linespc}]
    }
    set t [$canv create line $x $y1 [lindex $xvals end] $y1 \
	       -width $lthickness -fill black -tags tag.$id]
    $canv lower $t
    foreach tag $marks x $xvals wid $wvals {
	set xl [expr {$x + $delta}]
	set xr [expr {$x + $delta + $wid + $lthickness}]
	set font $mainfont
	if {[incr ntags -1] >= 0} {
	    # draw a tag
	    set t [$canv create polygon $x [expr {$yt + $delta}] $xl $yt \
		       $xr $yt $xr $yb $xl $yb $x [expr {$yb - $delta}] \
		       -width 1 -outline black -fill yellow -tags tag.$id]
	    $canv bind $t <1> [list showtag $tag 1]
	    set rowtextx([rowofcommit $curview $id]) [expr {$xr + $linespc}]
	} else {
	    # draw a head or other ref
	    if {[incr nheads -1] >= 0} {
		set col green
		if {$tag eq $mainhead} {
		    lappend font bold
		}
	    } else {
		set col "#ddddff"
	    }
	    set xl [expr {$xl - $delta/2}]
	    $canv create polygon $x $yt $xr $yt $xr $yb $x $yb \
		-width 1 -outline black -fill $col -tags tag.$id
	    if {[regexp {^(remotes/.*/|remotes/)} $tag match remoteprefix]} {
	        set rwid [font measure $mainfont $remoteprefix]
		set xi [expr {$x + 1}]
		set yti [expr {$yt + 1}]
		set xri [expr {$x + $rwid}]
		$canv create polygon $xi $yti $xri $yti $xri $yb $xi $yb \
			-width 0 -fill "#ffddaa" -tags tag.$id
	    }
	}
	set t [$canv create text $xl $y1 -anchor w -text $tag -fill $fgcolor \
		   -font $font -tags [list tag.$id text]]
	if {$ntags >= 0} {
	    $canv bind $t <1> [list showtag $tag 1]
	} elseif {$nheads >= 0} {
	    $canv bind $t <Button-3> [list headmenu %X %Y $id $tag]
	}
    }
    return $xt
}

proc xcoord {i level ln} {
    global canvx0 xspc1 xspc2

    set x [expr {$canvx0 + $i * $xspc1($ln)}]
    if {$i > 0 && $i == $level} {
	set x [expr {$x + 0.5 * ($xspc2 - $xspc1($ln))}]
    } elseif {$i > $level} {
	set x [expr {$x + $xspc2 - $xspc1($ln)}]
    }
    return $x
}

proc show_status {msg} {
    global canv mainfont fgcolor

    clear_display
    $canv create text 3 3 -anchor nw -text $msg -font $mainfont \
	-tags text -fill $fgcolor
}

# Compute a suitable token value to go between rows row-1 and row
proc tokenbefore {view row} {
    if {$row == 0} {
	set toka 0
    } else {
	set toka [tsv::lindex vtokenlist $view [expr {$row - 1}]]
    }
    set tokb [tsv::lindex vtokenlist $view $row]
    set tla [llength $toka]
    set tlb [llength $tokb]
    set res {}
    for {set i 0} {$i < $tla || $i < $tlb} {incr i} {
	set a [lindex $toka $i]
	if {$a eq {}} {
	    set a 0
	}
	set b [lindex $tokb $i]
	if {$b eq {}} {
	    set b 0
	}
	if {$a != $b} {
	    if {$a + 1 < $b} {
		set m [expr {($a + $b) / 2}]
	    } else {
		lappend res $a
		incr i
		set a [lindex $toka $i]
		if {$a eq {}} {
		    set m 1048576
		} else {
		    set m [expr {$a + 1024}]
		}
	    }
	    lappend res $m
	    if {[tokencmp $toka $res] >= 0 || [tokencmp $res $tokb] >= 0} {
		puts "OOPS tokens not in order"
	    }
	    return $res
	}
	lappend res $a
    }
    lappend res 1048576
    return $res
}

# Insert a new commit as the child of the commit on row $row.
# The new commit will be displayed on row $row and the commits
# on that row and below will move down one row.
proc insertrow {row newcmit} {
    global phase
    global curview numcommits
    global selectedline curview

    if {$row >= $numcommits} {
	puts "oops, inserting new row $row but only have $numcommits rows"
	return
    }
    set p [tsv::lindex disporder $curview $row]
    set newtok [tokenbefore $curview $row]
    tsv::lpush disporder $curview $newcmit $row
    tsv::set parents$curview $newcmit $p
    set kids [tsv::lappend children$curview $p $newcmit]
    tsv::set children$curview $newcmit {}
    tsv::lpush vcmitlisted $curview 1 $row
    tsv::set ctok$curview $newcmit $newtok
    tsv::lpush vtokenlist $curview $newtok $row

    set idlist [getrowids $row]
    if {[llength $kids] == 1} {
	set col [lsearch -exact $idlist $p]
	lset idlist $col $newcmit
    } else {
	set col [llength $idlist]
	lappend idlist $newcmit
    }

    if {[llength $kids] > 1} {
	set ranges [tsv::get idrowranges$curview $p]
	if {$ranges eq {}} {
	    set ranges [list $newcmit $p]
	} elseif {[lindex $ranges end-1] eq $p} {
	    lset ranges end-1 $newcmit
	}
	tsv::set idrowranges$curview $p $ranges
    }

    adjust_layout $row 1 $idlist
    incr numcommits
    if {[info exists selectedline] && $selectedline >= $row} {
	incr selectedline
    }

    redisplay
}

# Remove a commit that was inserted with insertrow on row $row.
proc removerow {row} {
    global phase
    global curview numcommits
    global selectedline

    if {$row >= $numcommits} {
	puts "oops, removing row $row but only have $numcommits rows"
	return
    }
    set rp1 [expr {$row + 1}]
    set id [tsv::lpop disporder $curview $row]
    set p [tsv::get parents$curview $id]
    tsv::unset parents$curview $id
    tsv::lpop vcmitlisted $curview $row
    tsv::lpop vtokenlist $curview $row
    tsv::unset ctok$curview $id
    set i [tsv::lsearch children$curview $p -exact $id]
    if {$i >= 0} {
	tsv::lpop children$curview $p $i
    }
    set nkids [tsv::llength children$curview $p]
    tsv::unset children$curview $id

    if {$nkids > 0} {
	set ranges [tsv::get idrowranges$curview $p]
	if {[lindex $ranges end-1] eq $id} {
	    tsv::set idrowranges$curview $p [lreplace $ranges end-1 end]
	}
    }

    adjust_layout $row -1 {}
    incr numcommits -1
    if {[info exists selectedline] && $selectedline > $row} {
	incr selectedline -1
    }

    redisplay
}

# Don't change the text pane cursor if it is currently the hand cursor,
# showing that we are over a sha1 ID link.
proc settextcursor {c} {
    global ctext curtextcursor

    if {[$ctext cget -cursor] == $curtextcursor} {
	$ctext config -cursor $c
    }
    set curtextcursor $c
}

proc nowbusy {what} {
    global isbusy

    if {[array names isbusy] eq {}} {
	. config -cursor watch
	settextcursor watch
    }
    set isbusy($what) 1
}

proc notbusy {what} {
    global isbusy maincursor textcursor

    catch {unset isbusy($what)}
    if {[array names isbusy] eq {}} {
	. config -cursor $maincursor
	settextcursor $textcursor
    }
}

proc findmatches {f} {
    global findtype foundstring foundstrlen
    if {$findtype == "Regexp"} {
	set matches [regexp -indices -all -inline $foundstring $f]
    } else {
	if {$findtype == "IgnCase"} {
	    set str [string tolower $f]
	} else {
	    set str $f
	}
	set matches {}
	set i 0
	while {[set j [string first $foundstring $str $i]] >= 0} {
	    lappend matches [list $j [expr {$j+$foundstrlen-1}]]
	    set i [expr {$j + $foundstrlen}]
	}
    }
    return $matches
}

proc dofind {} {
    global findtype findloc findstring markedmatches
    global numcommits linehtag linentag linedtag
    global mainfont canv canv2 canv3 selectedline
    global matchinglines foundstring foundstrlen matchstring
    global curview

    stopfindproc
    unmarkmatches
    cancel_next_highlight
    focus .
    set matchinglines {}
    if {$findtype == "IgnCase"} {
	set foundstring [string tolower $findstring]
    } else {
	set foundstring $findstring
    }
    set foundstrlen [string length $findstring]
    if {$foundstrlen == 0} return
    regsub -all {[*?\[\\]} $foundstring {\\&} matchstring
    set matchstring "*$matchstring*"
    if {![info exists selectedline]} {
	set oldsel -1
    } else {
	set oldsel $selectedline
    }
    set didsel 0
    set fldtypes {Headline Author Date Committer CDate Comments}
    set l -1
    foreach id [tsv::get disporder $curview] {
	set d [tsv::get cdata $id]
	incr l
	if {$findtype == "Regexp"} {
	    set doesmatch [regexp $foundstring $d]
	} elseif {$findtype == "IgnCase"} {
	    set doesmatch [string match -nocase $matchstring $d]
	} else {
	    set doesmatch [string match $matchstring $d]
	}
	if {!$doesmatch} continue
	if {![tsv::exists commitinfo $id]} {
	    getcommit $id
	}
	set info [tsv::get commitinfo $id]
	set doesmatch 0
	foreach f $info ty $fldtypes {
	    if {$findloc != "All fields" && $findloc != $ty} {
		continue
	    }
	    set matches [findmatches $f]
	    if {$matches == {}} continue
	    set doesmatch 1
	    if {$ty == "Headline"} {
		drawcommits $l
		markmatches $canv $l $f $linehtag($l) $matches $mainfont
	    } elseif {$ty == "Author"} {
		drawcommits $l
		markmatches $canv2 $l $f $linentag($l) $matches $mainfont
	    } elseif {$ty == "Date"} {
		drawcommits $l
		markmatches $canv3 $l $f $linedtag($l) $matches $mainfont
	    }
	}
	if {$doesmatch} {
	    lappend matchinglines $l
	    if {!$didsel && $l > $oldsel} {
		findselectline $l
		set didsel 1
	    }
	}
    }
    if {$matchinglines == {}} {
	bell
    } elseif {!$didsel} {
	findselectline [lindex $matchinglines 0]
    }
}

proc findselectline {l} {
    global findloc commentend ctext
    selectline $l 1
    if {$findloc == "All fields" || $findloc == "Comments"} {
	# highlight the matches in the comments
	set f [$ctext get 1.0 $commentend]
	set matches [findmatches $f]
	foreach match $matches {
	    set start [lindex $match 0]
	    set end [expr {[lindex $match 1] + 1}]
	    $ctext tag add found "1.0 + $start c" "1.0 + $end c"
	}
    }
}

proc findnext {restart} {
    global matchinglines selectedline
    if {![info exists matchinglines]} {
	if {$restart} {
	    dofind
	}
	return
    }
    if {![info exists selectedline]} return
    foreach l $matchinglines {
	if {$l > $selectedline} {
	    findselectline $l
	    return
	}
    }
    bell
}

proc findprev {} {
    global matchinglines selectedline
    if {![info exists matchinglines]} {
	dofind
	return
    }
    if {![info exists selectedline]} return
    set prev {}
    foreach l $matchinglines {
	if {$l >= $selectedline} break
	set prev $l
    }
    if {$prev != {}} {
	findselectline $prev
    } else {
	bell
    }
}

proc stopfindproc {{done 0}} {
    global findprocpid findprocfile findids
    global ctext findoldcursor phase maincursor textcursor
    global findinprogress

    catch {unset findids}
    if {[info exists findprocpid]} {
	if {!$done} {
	    catch {exec kill $findprocpid}
	}
	catch {close $findprocfile}
	unset findprocpid
    }
    catch {unset findinprogress}
    notbusy find
}

# mark a commit as matching by putting a yellow background
# behind the headline
proc markheadline {l id} {
    global canv mainfont linehtag

    drawcommits $l
    set bbox [$canv bbox $linehtag($l)]
    set t [$canv create rect $bbox -outline {} -tags matches -fill yellow]
    $canv lower $t
}

# mark the bits of a headline, author or date that match a find string
proc markmatches {canv l str tag matches font} {
    set bbox [$canv bbox $tag]
    set x0 [lindex $bbox 0]
    set y0 [lindex $bbox 1]
    set y1 [lindex $bbox 3]
    foreach match $matches {
	set start [lindex $match 0]
	set end [lindex $match 1]
	if {$start > $end} continue
	set xoff [font measure $font [string range $str 0 [expr {$start-1}]]]
	set xlen [font measure $font [string range $str 0 [expr {$end}]]]
	set t [$canv create rect [expr {$x0+$xoff}] $y0 \
		   [expr {$x0+$xlen+2}] $y1 \
		   -outline {} -tags matches -fill yellow]
	$canv lower $t
    }
}

proc unmarkmatches {} {
    global matchinglines findids
    allcanvs delete matches
    catch {unset matchinglines}
    catch {unset findids}
}

proc selcanvline {w x y} {
    global canv canvy0 ctext linespc
    global rowtextx
    set ymax [lindex [$canv cget -scrollregion] 3]
    if {$ymax == {}} return
    set yfrac [lindex [$canv yview] 0]
    set y [expr {$y + $yfrac * $ymax}]
    set l [expr {int(($y - $canvy0) / $linespc + 0.5)}]
    if {$l < 0} {
	set l 0
    }
    if {$w eq $canv} {
	if {![info exists rowtextx($l)] || $x < $rowtextx($l)} return
    }
    unmarkmatches
    selectline $l 1
}

proc commit_descriptor {p} {
    if {![tsv::exists commitinfo $p]} {
	getcommit $p
    }
    set l "..."
    if {[tsv::llength commitinfo $p] > 1} {
	set l [tsv::lindex commitinfo $p 0]
    }
    return "$p ($l)\n"
}

# append some text to the ctext widget, and make any SHA1 ID
# that we know about be a clickable link.
proc appendwithlinks {text tags} {
    global ctext linknum curview

    set start [$ctext index "end - 1c"]
    $ctext insert end $text $tags
    set links [regexp -indices -all -inline {[0-9a-f]{40}} $text]
    foreach l $links {
	set s [lindex $l 0]
	set e [lindex $l 1]
	set linkid [string range $text $s $e]
	if {![tsv::exists ctok$curview $linkid]} continue
	incr e
	$ctext tag add link "$start + $s c" "$start + $e c"
	$ctext tag add link$linknum "$start + $s c" "$start + $e c"
	$ctext tag bind link$linknum <1> \
	    [list selectline [rowofcommit $curview $linkid] 1]
	incr linknum
    }
    $ctext tag conf link -foreground blue -underline 1
    $ctext tag bind link <Enter> { %W configure -cursor hand2 }
    $ctext tag bind link <Leave> { %W configure -cursor $curtextcursor }
}

proc viewnextline {dir} {
    global canv linespc

    $canv delete hover
    set ymax [lindex [$canv cget -scrollregion] 3]
    set wnow [$canv yview]
    set wtop [expr {[lindex $wnow 0] * $ymax}]
    set newtop [expr {$wtop + $dir * $linespc}]
    if {$newtop < 0} {
	set newtop 0
    } elseif {$newtop > $ymax} {
	set newtop $ymax
    }
    allcanvs yview moveto [expr {$newtop * 1.0 / $ymax}]
}

# add a list of tag or branch names at position pos
# returns the number of names inserted
proc appendrefs {pos tags var} {
    global ctext linknum curview $var maxrefs

    # Don't do anything if pos has been deleted or is not at the end
    # of the line (meaning stuff has already been inserted here).
    if {[catch {set col [lindex [split [$ctext index $pos] .] 1]}] ||
	$col > [string length $pos] + 2} {
	return 0
    }
    if {[llength $tags] > $maxrefs} {
	$ctext insert $pos "many ([llength $tags])"
    } else {
	set tags [lsort $tags]
	set sep {}
	foreach tag $tags {
	    set id [set $var\($tag\)]
	    set lk link$linknum
	    incr linknum
	    $ctext insert $pos $sep
	    $ctext insert $pos $tag $lk
	    $ctext tag conf $lk -foreground blue
	    if {[tsv::exists ctok$curview $id]} {
		$ctext tag bind $lk <1> \
		    [list selectline [rowofcommit $curview $id] 1]
		$ctext tag conf $lk -underline 1
		$ctext tag bind $lk <Enter> { %W configure -cursor hand2 }
		$ctext tag bind $lk <Leave> { %W configure -cursor $curtextcursor }
	    }
	    set sep ", "
	}
    }
    return [llength $tags]
}

proc taglist {ids} {
    set tags {}
    foreach id $ids {
	set tags [concat $tags [tsv::get idtags $id]]
    }
    return $tags
}

# called when we have finished computing the nearby tags
proc dispneartags {} {
    global selectedline currentid ctext showneartags

    if {![info exists selectedline] || !$showneartags} return
    set id $currentid
    $ctext conf -state normal
    if {[tsv::exists desc_heads $id]} {
	if {[appendrefs branch [tsv::get desc_heads $id] headids] > 1} {
	    $ctext insert "branch linestart +6c" "es"
	}
    }
    if {[tsv::exists anc_tags $id]} {
	appendrefs follows [taglist [tsv::get anc_tags $id]] tagids
    }
    if {[tsv::exists desc_tags $id]} {
	appendrefs precedes [taglist [tsv::get desc_tags $id]] tagids
    }
    $ctext conf -state disabled
}

proc selectline {l isnew} {
    global canv canv2 canv3 ctext selectedline
    global linehtag linentag linedtag
    global canvy0 linespc curview
    global currentid sha1entry
    global commentend linknum
    global mergemax numcommits pending_select
    global cmitmode showneartags

    catch {unset pending_select}
    $canv delete hover
    normalline
    cancel_next_highlight
    if {$l < 0 || $l >= $numcommits} return
    set y [expr {$canvy0 + $l * $linespc}]
    set ymax [lindex [$canv cget -scrollregion] 3]
    set ytop [expr {$y - $linespc - 1}]
    set ybot [expr {$y + $linespc + 1}]
    set wnow [$canv yview]
    set wtop [expr {[lindex $wnow 0] * $ymax}]
    set wbot [expr {[lindex $wnow 1] * $ymax}]
    set wh [expr {$wbot - $wtop}]
    set newtop $wtop
    if {$ytop < $wtop} {
	if {$ybot < $wtop} {
	    set newtop [expr {$y - $wh / 2.0}]
	} else {
	    set newtop $ytop
	    if {$newtop > $wtop - $linespc} {
		set newtop [expr {$wtop - $linespc}]
	    }
	}
    } elseif {$ybot > $wbot} {
	if {$ytop > $wbot} {
	    set newtop [expr {$y - $wh / 2.0}]
	} else {
	    set newtop [expr {$ybot - $wh}]
	    if {$newtop < $wtop + $linespc} {
		set newtop [expr {$wtop + $linespc}]
	    }
	}
    }
    if {$newtop != $wtop} {
	if {$newtop < 0} {
	    set newtop 0
	}
	allcanvs yview moveto [expr {$newtop * 1.0 / $ymax}]
	drawvisible
    }

    if {![info exists linehtag($l)]} return
    $canv delete secsel
    set t [eval $canv create rect [$canv bbox $linehtag($l)] -outline {{}} \
	       -tags secsel -fill [$canv cget -selectbackground]]
    $canv lower $t
    $canv2 delete secsel
    set t [eval $canv2 create rect [$canv2 bbox $linentag($l)] -outline {{}} \
	       -tags secsel -fill [$canv2 cget -selectbackground]]
    $canv2 lower $t
    $canv3 delete secsel
    set t [eval $canv3 create rect [$canv3 bbox $linedtag($l)] -outline {{}} \
	       -tags secsel -fill [$canv3 cget -selectbackground]]
    $canv3 lower $t

    if {$isnew} {
	addtohistory [list selectline $l 0]
    }

    set selectedline $l

    set id [tsv::lindex disporder $curview $l]
    set currentid $id
    $sha1entry delete 0 end
    $sha1entry insert 0 $id
    $sha1entry selection from 0
    $sha1entry selection to end
    rhighlight_sel $id

    $ctext conf -state normal
    clear_ctext
    set linknum 0
    set info [tsv::get commitinfo $id]
    set date [formatdate [lindex $info 2]]
    $ctext insert end "Author: [lindex $info 1]  $date\n"
    set date [formatdate [lindex $info 4]]
    $ctext insert end "Committer: [lindex $info 3]  $date\n"
    if {[tsv::exists idtags $id]} {
	$ctext insert end "Tags:"
	foreach tag [tsv::get idtags $id] {
	    $ctext insert end " $tag"
	}
	$ctext insert end "\n"
    }
 
    set headers {}
    set olds [tsv::get parents$curview $id]
    if {[llength $olds] > 1} {
	set np 0
	foreach p $olds {
	    if {$np >= $mergemax} {
		set tag mmax
	    } else {
		set tag m$np
	    }
	    $ctext insert end "Parent: " $tag
	    appendwithlinks [commit_descriptor $p] {}
	    incr np
	}
    } else {
	foreach p $olds {
	    append headers "Parent: [commit_descriptor $p]"
	}
    }

    foreach c [tsv::get children$curview $id] {
	append headers "Child:  [commit_descriptor $c]"
    }

    # make anything that looks like a SHA1 ID be a clickable link
    appendwithlinks $headers {}
    if {$showneartags} {
	getallcommits
	$ctext insert end "Branch: \n"
	$ctext mark set branch "end -2c"
	if {[tsv::exists desc_heads $id]} {
	    if {[appendrefs branch [tsv::get desc_heads $id] headids] > 1} {
		# turn "Branch" into "Branches"
		$ctext insert "branch linestart +6c" "es"
	    }
	}
	$ctext insert end "Follows: \n"
	$ctext mark set follows "end -2c"
	if {[tsv::exists anc_tags $id]} {
	    appendrefs follows [taglist [tsv::get anc_tags $id]] tagids
	}
	$ctext insert end "Precedes: \n"
	$ctext mark set precedes "end -2c"
	if {[tsv::exists desc_tags $id]} {
	    appendrefs precedes [taglist [tsv::get desc_tags $id]] tagids
	}
    }
    $ctext insert end "\n"
    set comment [lindex $info 5]
    if {[string first "\r" $comment] >= 0} {
	set comment [string map {"\r" "\n    "} $comment]
    }
    appendwithlinks $comment {comment}

    $ctext tag delete Comments
    $ctext tag remove found 1.0 end
    $ctext conf -state disabled
    set commentend [$ctext index "end - 1c"]

    init_flist "Comments"
    if {$cmitmode eq "tree"} {
	gettree $id
    } elseif {[llength $olds] <= 1} {
	startdiff $id
    } else {
	mergediff $id $l
    }
}

proc selfirstline {} {
    unmarkmatches
    selectline 0 1
}

proc sellastline {} {
    global numcommits
    unmarkmatches
    set l [expr {$numcommits - 1}]
    selectline $l 1
}

proc selnextline {dir} {
    global selectedline
    if {![info exists selectedline]} return
    set l [expr {$selectedline + $dir}]
    unmarkmatches
    selectline $l 1
}

proc selnextpage {dir} {
    global canv linespc selectedline numcommits

    set lpp [expr {([winfo height $canv] - 2) / $linespc}]
    if {$lpp < 1} {
	set lpp 1
    }
    allcanvs yview scroll [expr {$dir * $lpp}] units
    drawvisible
    if {![info exists selectedline]} return
    set l [expr {$selectedline + $dir * $lpp}]
    if {$l < 0} {
	set l 0
    } elseif {$l >= $numcommits} {
        set l [expr $numcommits - 1]
    }
    unmarkmatches
    selectline $l 1    
}

proc unselectline {} {
    global selectedline currentid

    catch {unset selectedline}
    catch {unset currentid}
    allcanvs delete secsel
    rhighlight_none
    cancel_next_highlight
}

proc reselectline {} {
    global selectedline

    if {[info exists selectedline]} {
	selectline $selectedline 0
    }
}

proc addtohistory {cmd} {
    global history historyindex curview

    set elt [list $curview $cmd]
    if {$historyindex > 0
	&& [lindex $history [expr {$historyindex - 1}]] == $elt} {
	return
    }

    if {$historyindex < [llength $history]} {
	set history [lreplace $history $historyindex end $elt]
    } else {
	lappend history $elt
    }
    incr historyindex
    if {$historyindex > 1} {
	.ctop.top.bar.leftbut conf -state normal
    } else {
	.ctop.top.bar.leftbut conf -state disabled
    }
    .ctop.top.bar.rightbut conf -state disabled
}

proc godo {elt} {
    global curview

    set view [lindex $elt 0]
    set cmd [lindex $elt 1]
    if {$curview != $view} {
	showview $view
    }
    eval $cmd
}

proc goback {} {
    global history historyindex

    if {$historyindex > 1} {
	incr historyindex -1
	godo [lindex $history [expr {$historyindex - 1}]]
	.ctop.top.bar.rightbut conf -state normal
    }
    if {$historyindex <= 1} {
	.ctop.top.bar.leftbut conf -state disabled
    }
}

proc goforw {} {
    global history historyindex

    if {$historyindex < [llength $history]} {
	set cmd [lindex $history $historyindex]
	incr historyindex
	godo $cmd
	.ctop.top.bar.leftbut conf -state normal
    }
    if {$historyindex >= [llength $history]} {
	.ctop.top.bar.rightbut conf -state disabled
    }
}

proc gettree {id} {
    global treefilelist treeidlist diffids diffmergeid treepending nullid

    set diffids $id
    catch {unset diffmergeid}
    if {![info exists treefilelist($id)]} {
	if {![info exists treepending]} {
	    if {$id ne $nullid} {
		set cmd [concat | git ls-tree -r $id]
	    } else {
		set cmd [concat | git ls-files]
	    }
	    if {[catch {set gtf [open $cmd r]}]} {
		return
	    }
	    set treepending $id
	    set treefilelist($id) {}
	    set treeidlist($id) {}
	    fconfigure $gtf -blocking 0
	    filerun $gtf [list gettreeline $gtf $id]
	}
    } else {
	setfilelist $id
    }
}

proc gettreeline {gtf id} {
    global treefilelist treeidlist treepending cmitmode diffids nullid

    set nl 0
    while {[incr nl] <= 1000 && [gets $gtf line] >= 0} {
	if {$diffids ne $nullid} {
	    set tl [split $line "\t"]
	    if {[lindex $tl 0 1] ne "blob"} continue
	    set sha1 [lindex $tl 0 2]
	    set fname [lindex $tl 1]
	    if {[string index $fname 0] eq "\""} {
		set fname [lindex $fname 0]
	    }
	    lappend treeidlist($id) $sha1
	} else {
	    set fname $line
	}
	lappend treefilelist($id) $fname
    }
    if {![eof $gtf]} {
	return [expr {$nl >= 1000? 2: 1}]
    }
    close $gtf
    unset treepending
    if {$cmitmode ne "tree"} {
	if {![info exists diffmergeid]} {
	    gettreediffs $diffids
	}
    } elseif {$id ne $diffids} {
	gettree $diffids
    } else {
	setfilelist $id
    }
    return 0
}

proc showfile {f} {
    global treefilelist treeidlist diffids nullid
    global ctext commentend

    set i [lsearch -exact $treefilelist($diffids) $f]
    if {$i < 0} {
	puts "oops, $f not in list for id $diffids"
	return
    }
    if {$diffids ne $nullid} {
	set blob [lindex $treeidlist($diffids) $i]
	if {[catch {set bf [open [concat | git cat-file blob $blob] r]} err]} {
	    puts "oops, error reading blob $blob: $err"
	    return
	}
    } else {
	if {[catch {set bf [open $f r]} err]} {
	    puts "oops, can't read $f: $err"
	    return
	}
    }
    fconfigure $bf -blocking 0
    filerun $bf [list getblobline $bf $diffids]
    $ctext config -state normal
    clear_ctext $commentend
    $ctext insert end "\n"
    $ctext insert end "$f\n" filesep
    $ctext config -state disabled
    $ctext yview $commentend
}

proc getblobline {bf id} {
    global diffids cmitmode ctext

    if {$id ne $diffids || $cmitmode ne "tree"} {
	catch {close $bf}
	return 0
    }
    $ctext config -state normal
    set nl 0
    while {[incr nl] <= 1000 && [gets $bf line] >= 0} {
	$ctext insert end "$line\n"
    }
    if {[eof $bf]} {
	# delete last newline
	$ctext delete "end - 2c" "end - 1c"
	close $bf
	return 0
    }
    $ctext config -state disabled
    return [expr {$nl >= 1000? 2: 1}]
}

proc mergediff {id l} {
    global diffmergeid diffopts mdifffd
    global diffids
    global curview

    set diffmergeid $id
    set diffids $id
    # this doesn't seem to actually affect anything...
    set env(GIT_DIFF_OPTS) $diffopts
    set cmd [concat | git diff-tree --no-commit-id --cc $id]
    if {[catch {set mdf [open $cmd r]} err]} {
	error_popup "Error getting merge diffs: $err"
	return
    }
    fconfigure $mdf -blocking 0
    set mdifffd($id) $mdf
    set np [llength [tsv::get parents$curview $id]]
    filerun $mdf [list getmergediffline $mdf $id $np]
}

proc getmergediffline {mdf id np} {
    global diffmergeid ctext cflist mergemax
    global difffilestart mdifffd

    $ctext conf -state normal
    set nr 0
    while {[incr nr] <= 1000 && [gets $mdf line] >= 0} {
	if {![info exists diffmergeid] || $id != $diffmergeid
	    || $mdf != $mdifffd($id)} {
	    close $mdf
	    return 0
	}
	if {[regexp {^diff --cc (.*)} $line match fname]} {
	    # start of a new file
	    $ctext insert end "\n"
	    set here [$ctext index "end - 1c"]
	    lappend difffilestart $here
	    add_flist [list $fname]
	    set l [expr {(78 - [string length $fname]) / 2}]
	    set pad [string range "----------------------------------------" 1 $l]
	    $ctext insert end "$pad $fname $pad\n" filesep
	} elseif {[regexp {^@@} $line]} {
	    $ctext insert end "$line\n" hunksep
	} elseif {[regexp {^[0-9a-f]{40}$} $line] || [regexp {^index} $line]} {
	    # do nothing
	} else {
	    # parse the prefix - one ' ', '-' or '+' for each parent
	    set spaces {}
	    set minuses {}
	    set pluses {}
	    set isbad 0
	    for {set j 0} {$j < $np} {incr j} {
		set c [string range $line $j $j]
		if {$c == " "} {
		    lappend spaces $j
		} elseif {$c == "-"} {
		    lappend minuses $j
		} elseif {$c == "+"} {
		    lappend pluses $j
		} else {
		    set isbad 1
		    break
		}
	    }
	    set tags {}
	    set num {}
	    if {!$isbad && $minuses ne {} && $pluses eq {}} {
		# line doesn't appear in result, parents in $minuses have the line
		set num [lindex $minuses 0]
	    } elseif {!$isbad && $pluses ne {} && $minuses eq {}} {
		# line appears in result, parents in $pluses don't have the line
		lappend tags mresult
		set num [lindex $spaces 0]
	    }
	    if {$num ne {}} {
		if {$num >= $mergemax} {
		    set num "max"
		}
		lappend tags m$num
	    }
	    $ctext insert end "$line\n" $tags
	}
    }
    $ctext conf -state disabled
    if {[eof $mdf]} {
	close $mdf
	return 0
    }
    return [expr {$nr >= 1000? 2: 1}]
}

proc startdiff {ids} {
    global treediffs diffids treepending diffmergeid nullid

    set diffids $ids
    catch {unset diffmergeid}
    if {![info exists treediffs($ids)] || [lsearch -exact $ids $nullid] >= 0} {
	if {![info exists treepending]} {
	    gettreediffs $ids
	}
    } else {
	addtocflist $ids
    }
}

proc addtocflist {ids} {
    global treediffs cflist
    add_flist $treediffs($ids)
    getblobdiffs $ids
}

proc diffcmd {ids flags} {
    global nullid

    set i [lsearch -exact $ids $nullid]
    if {$i >= 0} {
	set cmd [concat | git diff-index $flags]
	if {[llength $ids] > 1} {
	    if {$i == 0} {
		lappend cmd -R [lindex $ids 1]
	    } else {
		lappend cmd [lindex $ids 0]
	    }
	} else {
	    lappend cmd HEAD
	}
    } else {
	set cmd [concat | git diff-tree --no-commit-id -r $flags $ids]
    }
    return $cmd
}

proc gettreediffs {ids} {
    global treediff treepending

    set treepending $ids
    set treediff {}
    if {[catch {set gdtf [open [diffcmd $ids {}] r]}]} return
    fconfigure $gdtf -blocking 0
    filerun $gdtf [list gettreediffline $gdtf $ids]
}

proc gettreediffline {gdtf ids} {
    global treediff treediffs treepending diffids diffmergeid
    global cmitmode

    set nr 0
    while {[incr nr] <= 1000 && [gets $gdtf line] >= 0} {
	set file [lindex $line 5]
	lappend treediff $file
    }
    if {![eof $gdtf]} {
	return [expr {$nr >= 1000? 2: 1}]
    }
    close $gdtf
    set treediffs($ids) $treediff
    unset treepending
    if {$cmitmode eq "tree"} {
	gettree $diffids
    } elseif {$ids != $diffids} {
	if {![info exists diffmergeid]} {
	    gettreediffs $diffids
	}
    } else {
	addtocflist $ids
    }
    return 0
}

proc getblobdiffs {ids} {
    global diffopts blobdifffd diffids env curdifftag curtagstart
    global diffinhdr treediffs

    set env(GIT_DIFF_OPTS) $diffopts
    if {[catch {set bdf [open [diffcmd $ids {-p -C}] r]} err]} {
	puts "error getting diffs: $err"
	return
    }
    set diffinhdr 0
    fconfigure $bdf -blocking 0
    set blobdifffd($ids) $bdf
    set curdifftag Comments
    set curtagstart 0.0
    filerun $bdf [list getblobdiffline $bdf $diffids]
}

proc setinlist {var i val} {
    global $var

    while {[llength [set $var]] < $i} {
	lappend $var {}
    }
    if {[llength [set $var]] == $i} {
	lappend $var $val
    } else {
	lset $var $i $val
    }
}

proc getblobdiffline {bdf ids} {
    global diffids blobdifffd ctext curdifftag curtagstart
    global diffnexthead diffnextnote difffilestart
    global diffinhdr treediffs

    set nr 0
    $ctext conf -state normal
    while {[incr nr] <= 1000 && [gets $bdf line] >= 0} {
	if {$ids != $diffids || $bdf != $blobdifffd($ids)} {
	    close $bdf
	    return 0
	}
	if {[regexp {^diff --git a/(.*) b/(.*)} $line match fname newname]} {
	    # start of a new file
	    $ctext insert end "\n"
	    $ctext tag add $curdifftag $curtagstart end
	    set here [$ctext index "end - 1c"]
	    set curtagstart $here
	    set header $newname
	    set i [lsearch -exact $treediffs($ids) $fname]
	    if {$i >= 0} {
		setinlist difffilestart $i $here
	    }
	    if {$newname ne $fname} {
		set i [lsearch -exact $treediffs($ids) $newname]
		if {$i >= 0} {
		    setinlist difffilestart $i $here
		}
	    }
	    set curdifftag "f:$fname"
	    $ctext tag delete $curdifftag
	    set l [expr {(78 - [string length $header]) / 2}]
	    set pad [string range "----------------------------------------" \
			 1 $l]
	    $ctext insert end "$pad $header $pad\n" filesep
	    set diffinhdr 1
	} elseif {$diffinhdr && [string compare -length 3 $line "---"] == 0} {
	    # do nothing
	} elseif {$diffinhdr && [string compare -length 3 $line "+++"] == 0} {
	    set diffinhdr 0
	} elseif {[regexp {^@@ -([0-9]+),([0-9]+) \+([0-9]+),([0-9]+) @@(.*)} \
		       $line match f1l f1c f2l f2c rest]} {
	    $ctext insert end "$line\n" hunksep
	    set diffinhdr 0
	} else {
	    set x [string range $line 0 0]
	    if {$x == "-" || $x == "+"} {
		set tag [expr {$x == "+"}]
		$ctext insert end "$line\n" d$tag
	    } elseif {$x == " "} {
		$ctext insert end "$line\n"
	    } elseif {$diffinhdr || $x == "\\"} {
		# e.g. "\ No newline at end of file"
		$ctext insert end "$line\n" filesep
	    } else {
		# Something else we don't recognize
		if {$curdifftag != "Comments"} {
		    $ctext insert end "\n"
		    $ctext tag add $curdifftag $curtagstart end
		    set curtagstart [$ctext index "end - 1c"]
		    set curdifftag Comments
		}
		$ctext insert end "$line\n" filesep
	    }
	}
    }
    $ctext conf -state disabled
    if {[eof $bdf]} {
	close $bdf
	if {$ids == $diffids && $bdf == $blobdifffd($ids)} {
	    $ctext tag add $curdifftag $curtagstart end
	}
	return 0
    }
    return [expr {$nr >= 1000? 2: 1}]
}

proc prevfile {} {
    global difffilestart ctext
    set prev [lindex $difffilestart 0]
    set here [$ctext index @0,0]
    foreach loc $difffilestart {
	if {[$ctext compare $loc >= $here]} {
	    $ctext yview $prev
	    return
	}
	set prev $loc
    }
    $ctext yview $prev
}

proc nextfile {} {
    global difffilestart ctext
    set here [$ctext index @0,0]
    foreach loc $difffilestart {
	if {[$ctext compare $loc > $here]} {
	    $ctext yview $loc
	    return
	}
    }
}

proc clear_ctext {{first 1.0}} {
    global ctext smarktop smarkbot

    set l [lindex [split $first .] 0]
    if {![info exists smarktop] || [$ctext compare $first < $smarktop.0]} {
	set smarktop $l
    }
    if {![info exists smarkbot] || [$ctext compare $first < $smarkbot.0]} {
	set smarkbot $l
    }
    $ctext delete $first end
}

proc incrsearch {name ix op} {
    global ctext searchstring searchdirn

    $ctext tag remove found 1.0 end
    if {[catch {$ctext index anchor}]} {
	# no anchor set, use start of selection, or of visible area
	set sel [$ctext tag ranges sel]
	if {$sel ne {}} {
	    $ctext mark set anchor [lindex $sel 0]
	} elseif {$searchdirn eq "-forwards"} {
	    $ctext mark set anchor @0,0
	} else {
	    $ctext mark set anchor @0,[winfo height $ctext]
	}
    }
    if {$searchstring ne {}} {
	set here [$ctext search $searchdirn -- $searchstring anchor]
	if {$here ne {}} {
	    $ctext see $here
	}
	searchmarkvisible 1
    }
}

proc dosearch {} {
    global sstring ctext searchstring searchdirn

    focus $sstring
    $sstring icursor end
    set searchdirn -forwards
    if {$searchstring ne {}} {
	set sel [$ctext tag ranges sel]
	if {$sel ne {}} {
	    set start "[lindex $sel 0] + 1c"
	} elseif {[catch {set start [$ctext index anchor]}]} {
	    set start "@0,0"
	}
	set match [$ctext search -count mlen -- $searchstring $start]
	$ctext tag remove sel 1.0 end
	if {$match eq {}} {
	    bell
	    return
	}
	$ctext see $match
	set mend "$match + $mlen c"
	$ctext tag add sel $match $mend
	$ctext mark unset anchor
    }
}

proc dosearchback {} {
    global sstring ctext searchstring searchdirn

    focus $sstring
    $sstring icursor end
    set searchdirn -backwards
    if {$searchstring ne {}} {
	set sel [$ctext tag ranges sel]
	if {$sel ne {}} {
	    set start [lindex $sel 0]
	} elseif {[catch {set start [$ctext index anchor]}]} {
	    set start @0,[winfo height $ctext]
	}
	set match [$ctext search -backwards -count ml -- $searchstring $start]
	$ctext tag remove sel 1.0 end
	if {$match eq {}} {
	    bell
	    return
	}
	$ctext see $match
	set mend "$match + $ml c"
	$ctext tag add sel $match $mend
	$ctext mark unset anchor
    }
}

proc searchmark {first last} {
    global ctext searchstring

    set mend $first.0
    while {1} {
	set match [$ctext search -count mlen -- $searchstring $mend $last.end]
	if {$match eq {}} break
	set mend "$match + $mlen c"
	$ctext tag add found $match $mend
    }
}

proc searchmarkvisible {doall} {
    global ctext smarktop smarkbot

    set topline [lindex [split [$ctext index @0,0] .] 0]
    set botline [lindex [split [$ctext index @0,[winfo height $ctext]] .] 0]
    if {$doall || $botline < $smarktop || $topline > $smarkbot} {
	# no overlap with previous
	searchmark $topline $botline
	set smarktop $topline
	set smarkbot $botline
    } else {
	if {$topline < $smarktop} {
	    searchmark $topline [expr {$smarktop-1}]
	    set smarktop $topline
	}
	if {$botline > $smarkbot} {
	    searchmark [expr {$smarkbot+1}] $botline
	    set smarkbot $botline
	}
    }
}

proc scrolltext {f0 f1} {
    global searchstring

    .ctop.cdet.left.sb set $f0 $f1
    if {$searchstring ne {}} {
	searchmarkvisible 0
    }
}

proc setcoords {} {
    global linespc charspc canvx0 canvy0 mainfont
    global xspc1 xspc2 lthickness

    set linespc [expr {int([font metrics $mainfont -linespace] * 0.9)}]
    set charspc [font measure $mainfont "m"]
    set canvy0 [expr {int(3 + 0.5 * $linespc)}]
    set canvx0 [expr {int(3 + 0.5 * $linespc)}]
    set lthickness [expr {int($linespc / 9) + 1}]
    set xspc1(0) $linespc
    set xspc2 $linespc
}

proc redisplay {} {
    global canv
    global selectedline

    set ymax [lindex [$canv cget -scrollregion] 3]
    if {$ymax eq {} || $ymax == 0} return
    set span [$canv yview]
    clear_display
    setcanvscroll
    allcanvs yview moveto [lindex $span 0]
    drawvisible
    if {[info exists selectedline]} {
	selectline $selectedline 0
	allcanvs yview moveto [lindex $span 0]
    }
}

proc incrfont {inc} {
    global mainfont textfont ctext canv phase
    global entries
    unmarkmatches
    set mainfont [lreplace $mainfont 1 1 [expr {[lindex $mainfont 1] + $inc}]]
    set textfont [lreplace $textfont 1 1 [expr {[lindex $textfont 1] + $inc}]]
    setcoords
    $ctext conf -font $textfont
    $ctext tag conf filesep -font [concat $textfont bold]
    foreach e $entries {
	$e conf -font $mainfont
    }
    if {$phase eq "getcommits"} {
	$canv itemconf textitems -font $mainfont
    }
    redisplay
}

proc clearsha1 {} {
    global sha1entry sha1string
    if {[string length $sha1string] == 40} {
	$sha1entry delete 0 end
    }
}

proc sha1change {n1 n2 op} {
    global sha1string currentid sha1but
    if {$sha1string == {}
	|| ([info exists currentid] && $sha1string == $currentid)} {
	set state disabled
    } else {
	set state normal
    }
    if {[$sha1but cget -state] == $state} return
    if {$state == "normal"} {
	$sha1but conf -state normal -relief raised -text "Goto: "
    } else {
	$sha1but conf -state disabled -relief flat -text "SHA1 ID: "
    }
}

proc gotocommit {} {
    global sha1string currentid tagids headids
    global numcommits curview

    if {$sha1string == {}
	|| ([info exists currentid] && $sha1string == $currentid)} return
    if {[info exists tagids($sha1string)]} {
	set id $tagids($sha1string)
    } elseif {[info exists headids($sha1string)]} {
	set id $headids($sha1string)
    } else {
	set id [string tolower $sha1string]
	if {[regexp {^[0-9a-f]{4,39}$} $id]} {
	    set matches {}
	    foreach i [tsv::get disporder $curview] {
		if {[string match $id* $i]} {
		    lappend matches $i
		}
	    }
	    if {$matches ne {}} {
		if {[llength $matches] > 1} {
		    error_popup "Short SHA1 id $id is ambiguous"
		    return
		}
		set id [lindex $matches 0]
	    }
	}
    }
    if {[tsv::exists ctok$curview $id]} {
	selectline [rowofcommit $curview $id] 1
	return
    }
    if {[regexp {^[0-9a-fA-F]{4,}$} $sha1string]} {
	set type "SHA1 id"
    } else {
	set type "Tag/Head"
    }
    error_popup "$type $sha1string is not known"
}

proc lineenter {x y id} {
    global hoverx hovery hoverid hovertimer
    global canv

    if {![tsv::exists commitinfo $id] && ![getcommit $id]} return
    set hoverx $x
    set hovery $y
    set hoverid $id
    if {[info exists hovertimer]} {
	after cancel $hovertimer
    }
    set hovertimer [after 500 linehover]
    $canv delete hover
}

proc linemotion {x y id} {
    global hoverx hovery hoverid hovertimer

    if {[info exists hoverid] && $id == $hoverid} {
	set hoverx $x
	set hovery $y
	if {[info exists hovertimer]} {
	    after cancel $hovertimer
	}
	set hovertimer [after 500 linehover]
    }
}

proc lineleave {id} {
    global hoverid hovertimer canv

    if {[info exists hoverid] && $id == $hoverid} {
	$canv delete hover
	if {[info exists hovertimer]} {
	    after cancel $hovertimer
	    unset hovertimer
	}
	unset hoverid
    }
}

proc linehover {} {
    global hoverx hovery hoverid hovertimer
    global canv linespc lthickness
    global mainfont

    set text [tsv::lindex commitinfo $hoverid 0]
    set ymax [lindex [$canv cget -scrollregion] 3]
    if {$ymax == {}} return
    set yfrac [lindex [$canv yview] 0]
    set x [expr {$hoverx + 2 * $linespc}]
    set y [expr {$hovery + $yfrac * $ymax - $linespc / 2}]
    set x0 [expr {$x - 2 * $lthickness}]
    set y0 [expr {$y - 2 * $lthickness}]
    set x1 [expr {$x + [font measure $mainfont $text] + 2 * $lthickness}]
    set y1 [expr {$y + $linespc + 2 * $lthickness}]
    set t [$canv create rectangle $x0 $y0 $x1 $y1 \
	       -fill \#ffff80 -outline black -width 1 -tags hover]
    $canv raise $t
    set t [$canv create text $x $y -anchor nw -text $text -tags hover \
	       -font $mainfont]
    $canv raise $t
}

proc clickisonarrow {id y} {
    global lthickness

    set ranges [rowranges $id]
    set thresh [expr {2 * $lthickness + 6}]
    set n [expr {[llength $ranges] - 1}]
    for {set i 1} {$i < $n} {incr i} {
	set row [lindex $ranges $i]
	if {abs([yc $row] - $y) < $thresh} {
	    return $i
	}
    }
    return {}
}

proc arrowjump {id n y} {
    global canv

    # 1 <-> 2, 3 <-> 4, etc...
    set n [expr {(($n - 1) ^ 1) + 1}]
    set row [lindex [rowranges $id] $n]
    set yt [yc $row]
    set ymax [lindex [$canv cget -scrollregion] 3]
    if {$ymax eq {} || $ymax <= 0} return
    set view [$canv yview]
    set yspan [expr {[lindex $view 1] - [lindex $view 0]}]
    set yfrac [expr {$yt / $ymax - $yspan / 2}]
    if {$yfrac < 0} {
	set yfrac 0
    }
    allcanvs yview moveto $yfrac
}

proc lineclick {x y id isnew} {
    global ctext canv thickerline curview

    if {![tsv::exists commitinfo $id] && ![getcommit $id]} return
    unmarkmatches
    unselectline
    normalline
    $canv delete hover
    # draw this line thicker than normal
    set thickerline $id
    drawlines $id
    if {$isnew} {
	set ymax [lindex [$canv cget -scrollregion] 3]
	if {$ymax eq {}} return
	set yfrac [lindex [$canv yview] 0]
	set y [expr {$y + $yfrac * $ymax}]
    }
    set dirn [clickisonarrow $id $y]
    if {$dirn ne {}} {
	arrowjump $id $dirn $y
	return
    }

    if {$isnew} {
	addtohistory [list lineclick $x $y $id 0]
    }
    # fill the details pane with info about this line
    $ctext conf -state normal
    clear_ctext
    $ctext tag conf link -foreground blue -underline 1
    $ctext tag bind link <Enter> { %W configure -cursor hand2 }
    $ctext tag bind link <Leave> { %W configure -cursor $curtextcursor }
    $ctext insert end "Parent:\t"
    $ctext insert end $id [list link link0]
    $ctext tag bind link0 <1> [list selbyid $id]
    set info [tsv::get commitinfo $id]
    $ctext insert end "\n\t[lindex $info 0]\n"
    $ctext insert end "\tAuthor:\t[lindex $info 1]\n"
    set date [formatdate [lindex $info 2]]
    $ctext insert end "\tDate:\t$date\n"
    set kids [tsv::get children$curview $id]
    if {$kids ne {}} {
	$ctext insert end "\nChildren:"
	set i 0
	foreach child $kids {
	    incr i
	    if {![tsv::exists commitinfo $child] && ![getcommit $child]} continue
	    set info [tsv::get commitinfo $child]
	    $ctext insert end "\n\t"
	    $ctext insert end $child [list link link$i]
	    $ctext tag bind link$i <1> [list selbyid $child]
	    $ctext insert end "\n\t[lindex $info 0]"
	    $ctext insert end "\n\tAuthor:\t[lindex $info 1]"
	    set date [formatdate [lindex $info 2]]
	    $ctext insert end "\n\tDate:\t$date\n"
	}
    }
    $ctext conf -state disabled
    init_flist {}
}

proc normalline {} {
    global thickerline
    if {[info exists thickerline]} {
	set id $thickerline
	unset thickerline
	drawlines $id
    }
}

proc selbyid {id} {
    global curview
    if {[tsv::exists ctok$curview $id]} {
	selectline [rowofcommit $curview $id] 1
    }
}

proc rowmenu {x y id} {
    global rowctxmenu selectedline rowmenuid curview
    global nullid fakerowmenu mainhead

    set rowmenuid $id
    if {![info exists selectedline]
	|| [rowofcommit $curview $id] eq $selectedline} {
	set state disabled
    } else {
	set state normal
    }
    if {$id ne $nullid} {
	set menu $rowctxmenu
	$menu entryconfigure 7 -label "Reset $mainhead branch to here"
    } else {
	set menu $fakerowmenu
    }
    $menu entryconfigure 0 -state $state
    $menu entryconfigure 1 -state $state
    $menu entryconfigure 2 -state $state
    tk_popup $menu $x $y
}

proc diffvssel {dirn} {
    global rowmenuid selectedline curview

    if {![info exists selectedline]} return
    if {$dirn} {
	set oldid [tsv::lindex disporder $curview $selectedline]
	set newid $rowmenuid
    } else {
	set oldid $rowmenuid
	set newid [tsv::lindex disporder $curview $selectedline]
    }
    addtohistory [list doseldiff $oldid $newid]
    doseldiff $oldid $newid
}

proc doseldiff {oldid newid} {
    global ctext

    $ctext conf -state normal
    clear_ctext
    init_flist "Top"
    $ctext insert end "From "
    $ctext tag conf link -foreground blue -underline 1
    $ctext tag bind link <Enter> { %W configure -cursor hand2 }
    $ctext tag bind link <Leave> { %W configure -cursor $curtextcursor }
    $ctext tag bind link0 <1> [list selbyid $oldid]
    $ctext insert end $oldid [list link link0]
    $ctext insert end "\n     "
    $ctext insert end [tsv::lindex commitinfo $oldid 0]
    $ctext insert end "\n\nTo   "
    $ctext tag bind link1 <1> [list selbyid $newid]
    $ctext insert end $newid [list link link1]
    $ctext insert end "\n     "
    $ctext insert end [tsv::lindex commitinfo $newid 0]
    $ctext insert end "\n"
    $ctext conf -state disabled
    $ctext tag delete Comments
    $ctext tag remove found 1.0 end
    startdiff [list $oldid $newid]
}

proc mkpatch {} {
    global rowmenuid currentid patchtop patchnum

    if {![info exists currentid]} return
    set oldid $currentid
    set oldhead [tsv::lindex commitinfo $oldid 0]
    set newid $rowmenuid
    set newhead [tsv::lindex commitinfo $newid 0]
    set top .patch
    set patchtop $top
    catch {destroy $top}
    toplevel $top
    label $top.title -text "Generate patch"
    grid $top.title - -pady 10
    label $top.from -text "From:"
    entry $top.fromsha1 -width 40 -relief flat
    $top.fromsha1 insert 0 $oldid
    $top.fromsha1 conf -state readonly
    grid $top.from $top.fromsha1 -sticky w
    entry $top.fromhead -width 60 -relief flat
    $top.fromhead insert 0 $oldhead
    $top.fromhead conf -state readonly
    grid x $top.fromhead -sticky w
    label $top.to -text "To:"
    entry $top.tosha1 -width 40 -relief flat
    $top.tosha1 insert 0 $newid
    $top.tosha1 conf -state readonly
    grid $top.to $top.tosha1 -sticky w
    entry $top.tohead -width 60 -relief flat
    $top.tohead insert 0 $newhead
    $top.tohead conf -state readonly
    grid x $top.tohead -sticky w
    button $top.rev -text "Reverse" -command mkpatchrev -padx 5
    grid $top.rev x -pady 10
    label $top.flab -text "Output file:"
    entry $top.fname -width 60
    $top.fname insert 0 [file normalize "patch$patchnum.patch"]
    incr patchnum
    grid $top.flab $top.fname -sticky w
    frame $top.buts
    button $top.buts.gen -text "Generate" -command mkpatchgo
    button $top.buts.can -text "Cancel" -command mkpatchcan
    grid $top.buts.gen $top.buts.can
    grid columnconfigure $top.buts 0 -weight 1 -uniform a
    grid columnconfigure $top.buts 1 -weight 1 -uniform a
    grid $top.buts - -pady 10 -sticky ew
    focus $top.fname
}

proc mkpatchrev {} {
    global patchtop

    set oldid [$patchtop.fromsha1 get]
    set oldhead [$patchtop.fromhead get]
    set newid [$patchtop.tosha1 get]
    set newhead [$patchtop.tohead get]
    foreach e [list fromsha1 fromhead tosha1 tohead] \
	    v [list $newid $newhead $oldid $oldhead] {
	$patchtop.$e conf -state normal
	$patchtop.$e delete 0 end
	$patchtop.$e insert 0 $v
	$patchtop.$e conf -state readonly
    }
}

proc mkpatchgo {} {
    global patchtop nullid

    set oldid [$patchtop.fromsha1 get]
    set newid [$patchtop.tosha1 get]
    set fname [$patchtop.fname get]
    if {$newid eq $nullid} {
	set cmd [list git diff-index -p $oldid]
    } elseif {$oldid eq $nullid} {
	set cmd [list git diff-index -p -R $newid]
    } else {
	set cmd [list git diff-tree -p $oldid $newid]
    }
    lappend cmd >$fname &
    if {[catch {eval exec $cmd} err]} {
	error_popup "Error creating patch: $err"
    }
    catch {destroy $patchtop}
    unset patchtop
}

proc mkpatchcan {} {
    global patchtop

    catch {destroy $patchtop}
    unset patchtop
}

proc mktag {} {
    global rowmenuid mktagtop

    set top .maketag
    set mktagtop $top
    catch {destroy $top}
    toplevel $top
    label $top.title -text "Create tag"
    grid $top.title - -pady 10
    label $top.id -text "ID:"
    entry $top.sha1 -width 40 -relief flat
    $top.sha1 insert 0 $rowmenuid
    $top.sha1 conf -state readonly
    grid $top.id $top.sha1 -sticky w
    entry $top.head -width 60 -relief flat
    $top.head insert 0 [tsv::lindex commitinfo $rowmenuid 0]
    $top.head conf -state readonly
    grid x $top.head -sticky w
    label $top.tlab -text "Tag name:"
    entry $top.tag -width 60
    grid $top.tlab $top.tag -sticky w
    frame $top.buts
    button $top.buts.gen -text "Create" -command mktaggo
    button $top.buts.can -text "Cancel" -command mktagcan
    grid $top.buts.gen $top.buts.can
    grid columnconfigure $top.buts 0 -weight 1 -uniform a
    grid columnconfigure $top.buts 1 -weight 1 -uniform a
    grid $top.buts - -pady 10 -sticky ew
    focus $top.tag
}

proc domktag {} {
    global mktagtop env tagids

    set id [$mktagtop.sha1 get]
    set tag [$mktagtop.tag get]
    if {$tag == {}} {
	error_popup "No tag name specified"
	return
    }
    if {[info exists tagids($tag)]} {
	error_popup "Tag \"$tag\" already exists"
	return
    }
    if {[catch {
	set dir [gitdir]
	set fname [file join $dir "refs/tags" $tag]
	set f [open $fname w]
	puts $f $id
	close $f
    } err]} {
	error_popup "Error creating tag: $err"
	return
    }

    set tagids($tag) $id
    tsv::lpush idtags $id $tag end
    redrawtags $id
    do_allcomm addedtag $id
}

proc redrawtags {id} {
    global canv linehtag idpos selectedline curview
    global mainfont canvxmax iddrawn

    if {![tsv::exists ctok$curview $id]} return
    if {![info exists iddrawn($id)]} return
    set row [rowofcommit $curview $id]
    drawcommits $row
    $canv delete tag.$id
    set xt [eval drawtags $id $idpos($id)]
    $canv coords $linehtag($row) $xt [lindex $idpos($id) 2]
    set text [$canv itemcget $linehtag($row) -text]
    set xr [expr {$xt + [font measure $mainfont $text]}]
    if {$xr > $canvxmax} {
	set canvxmax $xr
	setcanvscroll
    }
    if {[info exists selectedline] && $selectedline == $row} {
	selectline $selectedline 0
    }
}

proc mktagcan {} {
    global mktagtop

    catch {destroy $mktagtop}
    unset mktagtop
}

proc mktaggo {} {
    domktag
    mktagcan
}

proc writecommit {} {
    global rowmenuid wrcomtop wrcomcmd

    set top .writecommit
    set wrcomtop $top
    catch {destroy $top}
    toplevel $top
    label $top.title -text "Write commit to file"
    grid $top.title - -pady 10
    label $top.id -text "ID:"
    entry $top.sha1 -width 40 -relief flat
    $top.sha1 insert 0 $rowmenuid
    $top.sha1 conf -state readonly
    grid $top.id $top.sha1 -sticky w
    entry $top.head -width 60 -relief flat
    $top.head insert 0 [tsv::lindex commitinfo $rowmenuid 0]
    $top.head conf -state readonly
    grid x $top.head -sticky w
    label $top.clab -text "Command:"
    entry $top.cmd -width 60 -textvariable wrcomcmd
    grid $top.clab $top.cmd -sticky w -pady 10
    label $top.flab -text "Output file:"
    entry $top.fname -width 60
    $top.fname insert 0 [file normalize "commit-[string range $rowmenuid 0 6]"]
    grid $top.flab $top.fname -sticky w
    frame $top.buts
    button $top.buts.gen -text "Write" -command wrcomgo
    button $top.buts.can -text "Cancel" -command wrcomcan
    grid $top.buts.gen $top.buts.can
    grid columnconfigure $top.buts 0 -weight 1 -uniform a
    grid columnconfigure $top.buts 1 -weight 1 -uniform a
    grid $top.buts - -pady 10 -sticky ew
    focus $top.fname
}

proc wrcomgo {} {
    global wrcomtop

    set id [$wrcomtop.sha1 get]
    set cmd "echo $id | [$wrcomtop.cmd get]"
    set fname [$wrcomtop.fname get]
    if {[catch {exec sh -c $cmd >$fname &} err]} {
	error_popup "Error writing commit: $err"
    }
    catch {destroy $wrcomtop}
    unset wrcomtop
}

proc wrcomcan {} {
    global wrcomtop

    catch {destroy $wrcomtop}
    unset wrcomtop
}

proc mkbranch {} {
    global rowmenuid mkbrtop

    set top .makebranch
    catch {destroy $top}
    toplevel $top
    label $top.title -text "Create new branch"
    grid $top.title - -pady 10
    label $top.id -text "ID:"
    entry $top.sha1 -width 40 -relief flat
    $top.sha1 insert 0 $rowmenuid
    $top.sha1 conf -state readonly
    grid $top.id $top.sha1 -sticky w
    label $top.nlab -text "Name:"
    entry $top.name -width 40
    grid $top.nlab $top.name -sticky w
    frame $top.buts
    button $top.buts.go -text "Create" -command [list mkbrgo $top]
    button $top.buts.can -text "Cancel" -command "catch {destroy $top}"
    grid $top.buts.go $top.buts.can
    grid columnconfigure $top.buts 0 -weight 1 -uniform a
    grid columnconfigure $top.buts 1 -weight 1 -uniform a
    grid $top.buts - -pady 10 -sticky ew
    focus $top.name
}

proc mkbrgo {top} {
    set name [$top.name get]
    set id [$top.sha1 get]
    if {$name eq {}} {
	error_popup "Please specify a name for the new branch"
	return
    }
    catch {destroy $top}
    nowbusy newbranch
    update
    if {[catch {
	exec git branch $name $id
    } err]} {
	notbusy newbranch
	error_popup $err
    } else {
	addedhead $id $name
	# XXX should update list of heads displayed for selected commit
	notbusy newbranch
	redrawtags $id
    }
}

proc cherrypick {} {
    global rowmenuid curview mainhead

    if {[tsv::exists desc_heads $rowmenuid]
	&& [tsv::lsearch desc_heads $rowmenuid -exact $mainhead] >= 0} {
	set ok [confirm_popup "Commit [string range $rowmenuid 0 7] is already\
			included in branch $mainhead -- really re-apply it?"]
	if {!$ok} return
    }
    nowbusy cherrypick
    update
    set oldhead [exec git rev-parse HEAD]
    # Unfortunately git-cherry-pick writes stuff to stderr even when
    # no error occurs, and exec takes that as an indication of error...
    if {[catch {exec sh -c "git cherry-pick -r $rowmenuid 2>&1"} err]} {
	notbusy cherrypick
	error_popup $err
	return
    }
    set newhead [exec git rev-parse HEAD]
    if {$newhead eq $oldhead} {
	notbusy cherrypick
	error_popup "No changes committed"
	return
    }
    do_allcomm addcommit $newhead $oldhead $mainhead
    set row [rowofcommit $curview $oldhead]
    if {$row ne {}} {
	insertrow $row $newhead
	if {$mainhead ne {}} {
	    movedhead $newhead $mainhead
	}
	redrawtags $oldhead
	redrawtags $newhead
    }
    notbusy cherrypick
}

proc resethead {} {
    global mainheadid mainhead rowmenuid confirm_ok resettype

    set confirm_ok 0
    set w ".confirmreset"
    toplevel $w
    wm transient $w .
    wm title $w "Confirm reset"
    message $w.m -text \
	"Reset branch $mainhead to [string range $rowmenuid 0 7]?" \
	-justify center -aspect 1000
    pack $w.m -side top -fill x -padx 20 -pady 20
    frame $w.f -relief sunken -border 2
    message $w.f.rt -text "Reset type:" -aspect 1000
    grid $w.f.rt -sticky w
    set resettype mixed
    radiobutton $w.f.soft -value soft -variable resettype -justify left \
	-text "Soft: Leave working tree and index untouched"
    grid $w.f.soft -sticky w
    radiobutton $w.f.mixed -value mixed -variable resettype -justify left \
	-text "Mixed: Leave working tree untouched, reset index"
    grid $w.f.mixed -sticky w
    radiobutton $w.f.hard -value hard -variable resettype -justify left \
	-text "Hard: Reset working tree and index\n(discard ALL local changes)"
    grid $w.f.hard -sticky w
    pack $w.f -side top -fill x
    button $w.ok -text OK -command "set confirm_ok 1; destroy $w"
    pack $w.ok -side left -fill x -padx 20 -pady 20
    button $w.cancel -text Cancel -command "destroy $w"
    pack $w.cancel -side right -fill x -padx 20 -pady 20
    bind $w <Visibility> "grab $w; focus $w"
    tkwait window $w
    if {!$confirm_ok} return
    dohidelocalchanges
    if {[catch {exec git reset --$resettype $rowmenuid} err]} {
	error_popup $err
    } else {
	set oldhead $mainheadid
	movedhead $rowmenuid $mainhead
	set mainheadid $rowmenuid
	redrawtags $oldhead
	redrawtags $rowmenuid
    }
    if {[tsv::get options showlocalchanges]} {
	doshowlocalchanges
    }
}

# context menu for a head
proc headmenu {x y id head} {
    global headmenuid headmenuhead headctxmenu mainhead

    set headmenuid $id
    set headmenuhead $head
    set state disabled
    if {[tsv::exists desc_heads $id] && $head ne $mainhead} {
	set state normal
    }
    $headctxmenu entryconfigure 0 -state $state
    $headctxmenu entryconfigure 1 -state $state
    tk_popup $headctxmenu $x $y
}

proc cobranch {} {
    global headmenuid headmenuhead mainhead headids
    global mainheadid

    # check the tree is clean first??
    set oldmainhead $mainhead
    nowbusy checkout
    update
    dohidelocalchanges
    if {[catch {
	exec git checkout $headmenuhead
    } err]} {
	notbusy checkout
	error_popup $err
    } else {
	notbusy checkout
	set mainhead $headmenuhead
	set mainheadid $headmenuid
	if {[info exists headids($oldmainhead)]} {
	    redrawtags $headids($oldmainhead)
	}
	redrawtags $headmenuid
    }
    if {[tsv::get options showlocalchanges]} {
	dodiffindex
    }
}

proc rmbranch {} {
    global headmenuid headmenuhead mainhead

    set head $headmenuhead
    set id $headmenuid
    # this check shouldn't be needed any more...
    if {$head eq $mainhead} {
	error_popup "Cannot delete the currently checked-out branch"
	return
    }
    if {[tsv::get desc_heads $id] eq $head} {
	# the stuff on this branch isn't on any other branch
	if {![confirm_popup "The commits on branch $head aren't on any other\
			branch.\nReally delete branch $head?"]} return
    }
    nowbusy rmbranch
    update
    if {[catch {exec git branch -D $head} err]} {
	notbusy rmbranch
	error_popup $err
	return
    }
    removedhead $id $head
    redrawtags $id
    notbusy rmbranch
}

proc getallcommits {} {
    if {[tsv::exists allcommits {}]} return
    tsv::set allcommits {} "reading"
    do_allcomm readallcommits
    nowbusy allcommits
}

proc discardallcommits {} {
    if {![tsv::exists allcommits {}]} return
    # XXX implement me
    do_allcomm resetallcommits
}

proc allcommdone {} {
    notbusy allcommits
    dispneartags
}

# update the desc_heads array for a new head just added
proc addedhead {hid head} {
    global allparents headids

    set headids($head) $hid
    tsv::lpush idheads $hid $head end
    do_allcomm adjust_desc_heads $hid $head 1
}

# update desc_heads for a head being removed
proc removedhead {hid head} {
    global headids

    unset headids($head)
    set ids [tsv::get idheads $hid]
    if {$ids eq $head} {
	tsv::unset idheads $hid
    } else {
	set i [lsearch -exact $ids $head]
	if {$i >= 0} {
	    tsv::set idheads $hid [lreplace $ids $i $i]
	}
    }
    do_allcomm adjust_desc_heads $hid $head 0
}

# update things for a head moved to a child of its previous location
proc movedhead {id name} {
    global headids

    set oldid $headids($name)
    set headids($name) $id
    set ids [tsv::get idheads $oldid]
    if {$ids eq $name} {
	tsv::unset idheads $oldid
    } else {
	set i [lsearch -exact $ids $name]
	if {$i >= 0} {
	    tsv::set idheads $oldid [lreplace $ids $i $i]
	}
    }
    tsv::lpush idheads $id $name
}

# Stuff for finding nearby tags
set athreadstuff {
    proc gset {var val} {
	global $var
	set $var $val
    }

    proc readallcommits {} {
	global allcstart allcommits allcfd allids

	set allids {}
	set fd [open [concat | git rev-list --all --topo-order --parents] r]
	set allcfd $fd
	%ifnotthread% fconfigure $fd -blocking 0
	filerun $fd [list getallclines $fd]
	set allcstart [clock clicks -milliseconds]
    }

    proc resetallcommits {} {
	global allparents allchildren allcommits allcfd
	global desc_tags anc_tags alldtags tagisdesc allids
	global desc_heads

	if {![tsv::exists allcommits {}]} return
	if {[tsv::get allcommits {}] eq "reading"} {
	    catch {close $allcfd}
	}
	foreach v {allchildren allparents allids desc_tags anc_tags
	    desc_heads alldtags tagisdesc} {
	    catch {unset $v}
	}
	tsv::unset allcommits
	%ifathread% catch {tsv::unset desc_heads}
	%ifathread% catch {tsv::unset desc_tags}
	%ifathread% catch {tsv::unset anc_tags}
    }

    proc combine_dtags {l1 l2} {
	global tagisdesc notfirstd

	set res [lsort -unique [concat $l1 $l2]]
	for {set i 0} {$i < [llength $res]} {incr i} {
	    set x [lindex $res $i]
	    for {set j [expr {$i+1}]} {$j < [llength $res]} {} {
		set y [lindex $res $j]
		if {[info exists tagisdesc($x,$y)]} {
		    if {$tagisdesc($x,$y) > 0} {
			# x is a descendent of y, exclude x
			set res [lreplace $res $i $i]
			incr i -1
			break
		    } else {
			# y is a descendent of x, exclude y
			set res [lreplace $res $j $j]
		    }
		} else {
		    # no relation, keep going
		    incr j
		}
	    }
	}
	return $res
    }

    proc combine_atags {l1 l2} {
	global tagisdesc

	set res [lsort -unique [concat $l1 $l2]]
	for {set i 0} {$i < [llength $res]} {incr i} {
	    set x [lindex $res $i]
	    for {set j [expr {$i+1}]} {$j < [llength $res]} {} {
		set y [lindex $res $j]
		if {[info exists tagisdesc($x,$y)]} {
		    if {$tagisdesc($x,$y) < 0} {
			# x is an ancestor of y, exclude x
			set res [lreplace $res $i $i]
			incr i -1
			break
		    } else {
			# y is an ancestor of x, exclude y
			set res [lreplace $res $j $j]
		    }
		} else {
		    # no relation, keep going
		    incr j
		}
	    }
	}
	return $res
    }

    proc forward_pass {id children} {
	global desc_tags alldtags tagisdesc desc_heads
	%ifnotthread% global idtags idheads

	set dtags {}
	set dheads {}
	foreach child $children {
	    if {[%tsvexists% idtags $child]} {
		set ctags [list $child]
	    } else {
		set ctags $desc_tags($child)
	    }
	    if {$dtags eq {}} {
		set dtags $ctags
	    } elseif {$ctags ne $dtags} {
		set dtags [combine_dtags $dtags $ctags]
	    }
	    set cheads $desc_heads($child)
	    if {$dheads eq {}} {
		set dheads $cheads
	    } elseif {$cheads ne $dheads} {
		set dheads [lsort -unique [concat $dheads $cheads]]
	    }
	}
	set desc_tags($id) $dtags
	%ifathread% tsv::set desc_tags $id $dtags
	if {[%tsvexists% idtags $id]} {
	    set adt $dtags
	    foreach tag $dtags {
		set adt [concat $adt $alldtags($tag)]
	    }
	    set adt [lsort -unique $adt]
	    set alldtags($id) $adt
	    foreach tag $adt {
		set tagisdesc($id,$tag) -1
		set tagisdesc($tag,$id) 1
	    }
	}
	if {[%tsvexists% idheads $id]} {
	    set dheads [concat $dheads [%tsvget% idheads $id]]
	}
	set desc_heads($id) $dheads
	%ifathread% tsv::set desc_heads $id $dheads
    }

    proc getallclines {fd} {
	global allparents allchildren allcstart allids travindex

	set nc 0
	while {[incr nc] <= 1000 && [gets $fd line] >= 0} {
	    set id [lindex $line 0]
	    lappend allids $id
	    set olds [lrange $line 1 end]
	    set allparents($id) $olds
	    if {![info exists allchildren($id)]} {
		set allchildren($id) {}
	    }
	    foreach p $olds {
		lappend allchildren($p) $id
	    }
	    # compute nearest tagged descendents as we go
	    # also compute descendent heads
	    forward_pass $id $allchildren($id)
	}
	if {[eof $fd]} {
	    set travindex [llength $allids]
	    set allcommits "traversing"
	    run restartatags
	    if {[catch {close $fd} err]} {
		do_main error_popup "Error reading full commit graph: $err.\n\
			 Results may be incomplete."
	    }
	    return 0
	}
	return [expr {$nc >= 1000? 2: 1}]
    }

    # walk backward through the tree and compute nearest tagged ancestors
    proc restartatags {} {
	global allids allparents anc_tags travindex
	%ifnotthread% global idtags

	set i $travindex
	set imin [expr {$i <= 1000? 0: $i - 1000}]
	while {[incr i -1] >= $imin} {
	    set id [lindex $allids $i]
	    set atags {}
	    foreach p $allparents($id) {
		if {[%tsvexists% idtags $p]} {
		    set ptags [list $p]
		} else {
		    if {![info exists anc_tags($p)]} {
			puts "oops no anc_tags for [shortids $p] at [lsearch -exact -all $allids $p]"
			puts "  i=$i/[llength $allids] id=[shortids $id] parents={[shortids $allparents($id)]}"
			set ptags {}
		    } else {
			set ptags $anc_tags($p)
		    }
		}
		if {$atags eq {}} {
		    set atags $ptags
		} elseif {$ptags ne $atags} {
		    set atags [combine_atags $atags $ptags]
		}
	    }
	    set anc_tags($id) $atags
	    %ifathread% tsv::set anc_tags $id $atags
	}
	set travindex [expr {$i+1}]
	if {$i >= 0} {
	    return 1
	}
	tsv::set allcommits {} "done"
	#global allcstart
	#puts "took [expr {[clock clicks -milliseconds] - $allcstart}]ms to read all commits"
	do_main allcommdone
	return 0
    }

    # update the desc_tags and anc_tags arrays for a new tag just added
    proc addedtag {id} {
	global desc_tags anc_tags allparents allchildren allcommits
	global tagisdesc alldtags
	%ifnotthread% global idtags

	if {![info exists desc_tags($id)]} return
	set adt $desc_tags($id)
	foreach t $desc_tags($id) {
	    set adt [concat $adt $alldtags($t)]
	}
	set adt [lsort -unique $adt]
	set alldtags($id) $adt
	foreach t $adt {
	    set tagisdesc($id,$t) -1
	    set tagisdesc($t,$id) 1
	}
	if {[info exists anc_tags($id)]} {
	    set todo $anc_tags($id)
	    while {$todo ne {}} {
		set do [lindex $todo 0]
		set todo [lrange $todo 1 end]
		if {[info exists tagisdesc($id,$do)]} continue
		set tagisdesc($do,$id) -1
		set tagisdesc($id,$do) 1
		if {[info exists anc_tags($do)]} {
		    set todo [concat $todo $anc_tags($do)]
		}
	    }
	}

	set lastold $desc_tags($id)
	set lastnew [list $id]
	set nup 0
	set nch 0
	set todo $allparents($id)
	while {$todo ne {}} {
	    set do [lindex $todo 0]
	    set todo [lrange $todo 1 end]
	    if {![info exists desc_tags($do)]} continue
	    if {$desc_tags($do) ne $lastold} {
		set lastold $desc_tags($do)
		set lastnew [combine_dtags $lastold [list $id]]
		incr nch
	    }
	    if {$lastold eq $lastnew} continue
	    set desc_tags($do) $lastnew
	    %ifathread% tsv::set desc_tags $do $lastnew
	    incr nup
	    if {![%tsvexists% idtags $do]} {
		set todo [concat $todo $allparents($do)]
	    }
	}

	if {![info exists anc_tags($id)]} return
	set lastold $anc_tags($id)
	set lastnew [list $id]
	set nup 0
	set nch 0
	set todo $allchildren($id)
	while {$todo ne {}} {
	    set do [lindex $todo 0]
	    set todo [lrange $todo 1 end]
	    if {![info exists anc_tags($do)]} continue
	    if {$anc_tags($do) ne $lastold} {
		set lastold $anc_tags($do)
		set lastnew [combine_atags $lastold [list $id]]
		incr nch
	    }
	    if {$lastold eq $lastnew} continue
	    set anc_tags($do) $lastnew
	    %ifathread% tsv::set anc_tags $do $lastnew
	    incr nup
	    if {![%tsvexists% idtags $do]} {
		set todo [concat $todo $allchildren($do)]
	    }
	}
    }

    # update the desc_heads array for a head just removed
    proc adjust_desc_heads {hid head added} {
	global allparents desc_heads

	set todo [list $hid]
	while {$todo ne {}} {
	    set do [lindex $todo 0]
	    set todo [lrange $todo 1 end]
	    if {![info exists desc_heads($do)]} continue
	    set oldheads $desc_heads($do)
	    set i [lsearch -exact $oldheads $head]
	    if {$added} {
		if {$i >= 0} continue
		set heads [linsert desc_heads($do) $head end]
	    } else {
		if {$i < 0} continue
		set heads [lreplace $desc_heads($do) $i $i]
	    }
	    while {1} {
		set desc_heads($do) $heads
		%ifathread% tsv::set desc_heads $do $heads
		set p $allparents($do)
		if {[llength $p] != 1 || ![info exists desc_heads($p)] ||
		    $desc_heads($p) ne $oldheads} break
		set do $p
	    }
	    set todo [concat $todo $p]
	}
    }

    proc addcommit {newhead oldhead mainhead} {
	global allparents allchildren desc_heads desc_tags anc_tags

	set allparents($newhead) $oldhead
	lappend allchildren($oldhead) $newhead
	set desc_heads($newhead) $mainhead
	%ifathread% tsv::set desc_heads $newhead $mainhead
	if {[info exists anc_tags($oldhead)]} {
	    set anc_tags($newhead) $anc_tags($oldhead)
	    %ifathread% tsv::set anc_tags $newhead $anc_tags($oldhead)
	}
	set desc_tags($newhead) {}
	%ifathread% tsv::set desc_tags $newhead {}
    }
}

proc rereadrefs {} {
    global idotherrefs mainhead

    set refids [concat [tsv::array names idtags] \
		    [tsv::array names idheads] [array names idotherrefs]]
    foreach id $refids {
	if {![info exists ref($id)]} {
	    set ref($id) [listrefs $id]
	}
    }
    set oldmainhead $mainhead
    readrefs
    changedrefs
    set refids [lsort -unique [concat $refids [tsv::array names idtags] \
			[tsv::array names idheads] [array names idotherrefs]]]
    foreach id $refids {
	set v [listrefs $id]
	if {![info exists ref($id)] || $ref($id) != $v ||
	    ($id eq $oldmainhead && $id ne $mainhead) ||
	    ($id eq $mainhead && $id ne $oldmainhead)} {
	    redrawtags $id
	}
    }
}

proc listrefs {id} {
    global idotherrefs

    set x {}
    if {[tsv::exists idtags $id]} {
	set x [tsv::get idtags $id]
    }
    set y {}
    if {[tsv::exists idheads $id]} {
	set y [tsv::get idheads $id]
    }
    set z {}
    if {[info exists idotherrefs($id)]} {
	set z $idotherrefs($id)
    }
    return [list $x $y $z]
}

proc showtag {tag isnew} {
    global ctext tagcontents tagids linknum tagobjid

    if {$isnew} {
	addtohistory [list showtag $tag 0]
    }
    $ctext conf -state normal
    clear_ctext
    set linknum 0
    if {![info exists tagcontents($tag)]} {
	catch {
	    set tagcontents($tag) [exec git cat-file tag $tagobjid($tag)]
	}
    }
    if {[info exists tagcontents($tag)]} {
	set text $tagcontents($tag)
    } else {
	set text "Tag: $tag\nId:  $tagids($tag)"
    }
    appendwithlinks $text {}
    $ctext conf -state disabled
    init_flist {}
}

proc doquit {} {
    global stopped
    set stopped 100
    destroy .
}

proc doprefs {} {
    global maxgraphpct diffopts
    global oldprefs prefstop showneartags
    global bgcolor fgcolor ctext diffcolors

    set top .gitkprefs
    set prefstop $top
    if {[winfo exists $top]} {
	raise $top
	return
    }
    foreach v {maxgraphpct diffopts showneartags} {
	set oldprefs($v) [set $v]
    }
    foreach v {maxwidth showlocalchanges} {
	global new$v
	set new$v [tsv::get options $v]
    }
    toplevel $top
    wm title $top "Gitk preferences"
    label $top.ldisp -text "Commit list display options"
    grid $top.ldisp - -sticky w -pady 10
    label $top.spacer -text " "
    label $top.maxwidthl -text "Maximum graph width (lines)" \
	-font optionfont
    spinbox $top.maxwidth -from 0 -to 100 -width 4 -textvariable newmaxwidth
    grid $top.spacer $top.maxwidthl $top.maxwidth -sticky w
    label $top.maxpctl -text "Maximum graph width (% of pane)" \
	-font optionfont
    spinbox $top.maxpct -from 1 -to 100 -width 4 -textvariable maxgraphpct
    grid x $top.maxpctl $top.maxpct -sticky w
    frame $top.showlocal
    label $top.showlocal.l -text "Show local changes" -font optionfont
    checkbutton $top.showlocal.b -variable newshowlocalchanges
    pack $top.showlocal.b $top.showlocal.l -side left
    grid x $top.showlocal -sticky w

    label $top.ddisp -text "Diff display options"
    grid $top.ddisp - -sticky w -pady 10
    label $top.diffoptl -text "Options for diff program" \
	-font optionfont
    entry $top.diffopt -width 20 -textvariable diffopts
    grid x $top.diffoptl $top.diffopt -sticky w
    frame $top.ntag
    label $top.ntag.l -text "Display nearby tags" -font optionfont
    checkbutton $top.ntag.b -variable showneartags
    pack $top.ntag.b $top.ntag.l -side left
    grid x $top.ntag -sticky w

    label $top.cdisp -text "Colors: press to choose"
    grid $top.cdisp - -sticky w -pady 10
    label $top.bg -padx 40 -relief sunk -background $bgcolor
    button $top.bgbut -text "Background" -font optionfont \
	-command [list choosecolor bgcolor 0 $top.bg background setbg]
    grid x $top.bgbut $top.bg -sticky w
    label $top.fg -padx 40 -relief sunk -background $fgcolor
    button $top.fgbut -text "Foreground" -font optionfont \
	-command [list choosecolor fgcolor 0 $top.fg foreground setfg]
    grid x $top.fgbut $top.fg -sticky w
    label $top.diffold -padx 40 -relief sunk -background [lindex $diffcolors 0]
    button $top.diffoldbut -text "Diff: old lines" -font optionfont \
	-command [list choosecolor diffcolors 0 $top.diffold "diff old lines" \
		      [list $ctext tag conf d0 -foreground]]
    grid x $top.diffoldbut $top.diffold -sticky w
    label $top.diffnew -padx 40 -relief sunk -background [lindex $diffcolors 1]
    button $top.diffnewbut -text "Diff: new lines" -font optionfont \
	-command [list choosecolor diffcolors 1 $top.diffnew "diff new lines" \
		      [list $ctext tag conf d1 -foreground]]
    grid x $top.diffnewbut $top.diffnew -sticky w
    label $top.hunksep -padx 40 -relief sunk -background [lindex $diffcolors 2]
    button $top.hunksepbut -text "Diff: hunk header" -font optionfont \
	-command [list choosecolor diffcolors 2 $top.hunksep \
		      "diff hunk header" \
		      [list $ctext tag conf hunksep -foreground]]
    grid x $top.hunksepbut $top.hunksep -sticky w

    frame $top.buts
    button $top.buts.ok -text "OK" -command prefsok
    button $top.buts.can -text "Cancel" -command prefscan
    grid $top.buts.ok $top.buts.can
    grid columnconfigure $top.buts 0 -weight 1 -uniform a
    grid columnconfigure $top.buts 1 -weight 1 -uniform a
    grid $top.buts - - -pady 10 -sticky ew
}

proc choosecolor {v vi w x cmd} {
    global $v

    set c [tk_chooseColor -initialcolor [lindex [set $v] $vi] \
	       -title "Gitk: choose color for $x"]
    if {$c eq {}} return
    $w conf -background $c
    lset $v $vi $c
    eval $cmd $c
}

proc setbg {c} {
    global bglist

    foreach w $bglist {
	$w conf -background $c
    }
}

proc setfg {c} {
    global fglist canv

    foreach w $fglist {
	$w conf -foreground $c
    }
    allcanvs itemconf text -fill $c
    $canv itemconf circle -outline $c
}

proc prefscan {} {
    global maxgraphpct diffopts
    global oldprefs prefstop showneartags

    foreach v {maxgraphpct diffopts showneartags} {
	set $v $oldprefs($v)
    }
    catch {destroy $prefstop}
    unset prefstop
}

proc prefsok {} {
    global newmaxwidth maxgraphpct
    global oldprefs prefstop showneartags newshowlocalchanges

    catch {destroy $prefstop}
    unset prefstop
    if {[tsv::get options showlocalchanges] != $newshowlocalchanges} {
	tsv::set options showlocalchanges $newshowlocalchanges
	if {$newshowlocalchanges} {
	    doshowlocalchanges
	} else {
	    dohidelocalchanges
	}
    }
    if {[tsv::get options maxwidth] != $newmaxwidth
	|| $maxgraphpct != $oldprefs(maxgraphpct)} {
	tsv::set options maxwidth $newmaxwidth
	redisplay
    } elseif {$showneartags != $oldprefs(showneartags)} {
	reselectline
    }
}

proc formatdate {d} {
    if {$d ne {}} {
	set d [clock format $d -format "%Y-%m-%d %H:%M:%S"]
    }
    return $d
}

# This list of encoding names and aliases is distilled from
# http://www.iana.org/assignments/character-sets.
# Not all of them are supported by Tcl.
set encoding_aliases {
    { ANSI_X3.4-1968 iso-ir-6 ANSI_X3.4-1986 ISO_646.irv:1991 ASCII
      ISO646-US US-ASCII us IBM367 cp367 csASCII }
    { ISO-10646-UTF-1 csISO10646UTF1 }
    { ISO_646.basic:1983 ref csISO646basic1983 }
    { INVARIANT csINVARIANT }
    { ISO_646.irv:1983 iso-ir-2 irv csISO2IntlRefVersion }
    { BS_4730 iso-ir-4 ISO646-GB gb uk csISO4UnitedKingdom }
    { NATS-SEFI iso-ir-8-1 csNATSSEFI }
    { NATS-SEFI-ADD iso-ir-8-2 csNATSSEFIADD }
    { NATS-DANO iso-ir-9-1 csNATSDANO }
    { NATS-DANO-ADD iso-ir-9-2 csNATSDANOADD }
    { SEN_850200_B iso-ir-10 FI ISO646-FI ISO646-SE se csISO10Swedish }
    { SEN_850200_C iso-ir-11 ISO646-SE2 se2 csISO11SwedishForNames }
    { KS_C_5601-1987 iso-ir-149 KS_C_5601-1989 KSC_5601 korean csKSC56011987 }
    { ISO-2022-KR csISO2022KR }
    { EUC-KR csEUCKR }
    { ISO-2022-JP csISO2022JP }
    { ISO-2022-JP-2 csISO2022JP2 }
    { JIS_C6220-1969-jp JIS_C6220-1969 iso-ir-13 katakana x0201-7
      csISO13JISC6220jp }
    { JIS_C6220-1969-ro iso-ir-14 jp ISO646-JP csISO14JISC6220ro }
    { IT iso-ir-15 ISO646-IT csISO15Italian }
    { PT iso-ir-16 ISO646-PT csISO16Portuguese }
    { ES iso-ir-17 ISO646-ES csISO17Spanish }
    { greek7-old iso-ir-18 csISO18Greek7Old }
    { latin-greek iso-ir-19 csISO19LatinGreek }
    { DIN_66003 iso-ir-21 de ISO646-DE csISO21German }
    { NF_Z_62-010_(1973) iso-ir-25 ISO646-FR1 csISO25French }
    { Latin-greek-1 iso-ir-27 csISO27LatinGreek1 }
    { ISO_5427 iso-ir-37 csISO5427Cyrillic }
    { JIS_C6226-1978 iso-ir-42 csISO42JISC62261978 }
    { BS_viewdata iso-ir-47 csISO47BSViewdata }
    { INIS iso-ir-49 csISO49INIS }
    { INIS-8 iso-ir-50 csISO50INIS8 }
    { INIS-cyrillic iso-ir-51 csISO51INISCyrillic }
    { ISO_5427:1981 iso-ir-54 ISO5427Cyrillic1981 }
    { ISO_5428:1980 iso-ir-55 csISO5428Greek }
    { GB_1988-80 iso-ir-57 cn ISO646-CN csISO57GB1988 }
    { GB_2312-80 iso-ir-58 chinese csISO58GB231280 }
    { NS_4551-1 iso-ir-60 ISO646-NO no csISO60DanishNorwegian
      csISO60Norwegian1 }
    { NS_4551-2 ISO646-NO2 iso-ir-61 no2 csISO61Norwegian2 }
    { NF_Z_62-010 iso-ir-69 ISO646-FR fr csISO69French }
    { videotex-suppl iso-ir-70 csISO70VideotexSupp1 }
    { PT2 iso-ir-84 ISO646-PT2 csISO84Portuguese2 }
    { ES2 iso-ir-85 ISO646-ES2 csISO85Spanish2 }
    { MSZ_7795.3 iso-ir-86 ISO646-HU hu csISO86Hungarian }
    { JIS_C6226-1983 iso-ir-87 x0208 JIS_X0208-1983 csISO87JISX0208 }
    { greek7 iso-ir-88 csISO88Greek7 }
    { ASMO_449 ISO_9036 arabic7 iso-ir-89 csISO89ASMO449 }
    { iso-ir-90 csISO90 }
    { JIS_C6229-1984-a iso-ir-91 jp-ocr-a csISO91JISC62291984a }
    { JIS_C6229-1984-b iso-ir-92 ISO646-JP-OCR-B jp-ocr-b
      csISO92JISC62991984b }
    { JIS_C6229-1984-b-add iso-ir-93 jp-ocr-b-add csISO93JIS62291984badd }
    { JIS_C6229-1984-hand iso-ir-94 jp-ocr-hand csISO94JIS62291984hand }
    { JIS_C6229-1984-hand-add iso-ir-95 jp-ocr-hand-add
      csISO95JIS62291984handadd }
    { JIS_C6229-1984-kana iso-ir-96 csISO96JISC62291984kana }
    { ISO_2033-1983 iso-ir-98 e13b csISO2033 }
    { ANSI_X3.110-1983 iso-ir-99 CSA_T500-1983 NAPLPS csISO99NAPLPS }
    { ISO_8859-1:1987 iso-ir-100 ISO_8859-1 ISO-8859-1 latin1 l1 IBM819
      CP819 csISOLatin1 }
    { ISO_8859-2:1987 iso-ir-101 ISO_8859-2 ISO-8859-2 latin2 l2 csISOLatin2 }
    { T.61-7bit iso-ir-102 csISO102T617bit }
    { T.61-8bit T.61 iso-ir-103 csISO103T618bit }
    { ISO_8859-3:1988 iso-ir-109 ISO_8859-3 ISO-8859-3 latin3 l3 csISOLatin3 }
    { ISO_8859-4:1988 iso-ir-110 ISO_8859-4 ISO-8859-4 latin4 l4 csISOLatin4 }
    { ECMA-cyrillic iso-ir-111 KOI8-E csISO111ECMACyrillic }
    { CSA_Z243.4-1985-1 iso-ir-121 ISO646-CA csa7-1 ca csISO121Canadian1 }
    { CSA_Z243.4-1985-2 iso-ir-122 ISO646-CA2 csa7-2 csISO122Canadian2 }
    { CSA_Z243.4-1985-gr iso-ir-123 csISO123CSAZ24341985gr }
    { ISO_8859-6:1987 iso-ir-127 ISO_8859-6 ISO-8859-6 ECMA-114 ASMO-708
      arabic csISOLatinArabic }
    { ISO_8859-6-E csISO88596E ISO-8859-6-E }
    { ISO_8859-6-I csISO88596I ISO-8859-6-I }
    { ISO_8859-7:1987 iso-ir-126 ISO_8859-7 ISO-8859-7 ELOT_928 ECMA-118
      greek greek8 csISOLatinGreek }
    { T.101-G2 iso-ir-128 csISO128T101G2 }
    { ISO_8859-8:1988 iso-ir-138 ISO_8859-8 ISO-8859-8 hebrew
      csISOLatinHebrew }
    { ISO_8859-8-E csISO88598E ISO-8859-8-E }
    { ISO_8859-8-I csISO88598I ISO-8859-8-I }
    { CSN_369103 iso-ir-139 csISO139CSN369103 }
    { JUS_I.B1.002 iso-ir-141 ISO646-YU js yu csISO141JUSIB1002 }
    { ISO_6937-2-add iso-ir-142 csISOTextComm }
    { IEC_P27-1 iso-ir-143 csISO143IECP271 }
    { ISO_8859-5:1988 iso-ir-144 ISO_8859-5 ISO-8859-5 cyrillic
      csISOLatinCyrillic }
    { JUS_I.B1.003-serb iso-ir-146 serbian csISO146Serbian }
    { JUS_I.B1.003-mac macedonian iso-ir-147 csISO147Macedonian }
    { ISO_8859-9:1989 iso-ir-148 ISO_8859-9 ISO-8859-9 latin5 l5 csISOLatin5 }
    { greek-ccitt iso-ir-150 csISO150 csISO150GreekCCITT }
    { NC_NC00-10:81 cuba iso-ir-151 ISO646-CU csISO151Cuba }
    { ISO_6937-2-25 iso-ir-152 csISO6937Add }
    { GOST_19768-74 ST_SEV_358-88 iso-ir-153 csISO153GOST1976874 }
    { ISO_8859-supp iso-ir-154 latin1-2-5 csISO8859Supp }
    { ISO_10367-box iso-ir-155 csISO10367Box }
    { ISO-8859-10 iso-ir-157 l6 ISO_8859-10:1992 csISOLatin6 latin6 }
    { latin-lap lap iso-ir-158 csISO158Lap }
    { JIS_X0212-1990 x0212 iso-ir-159 csISO159JISX02121990 }
    { DS_2089 DS2089 ISO646-DK dk csISO646Danish }
    { us-dk csUSDK }
    { dk-us csDKUS }
    { JIS_X0201 X0201 csHalfWidthKatakana }
    { KSC5636 ISO646-KR csKSC5636 }
    { ISO-10646-UCS-2 csUnicode }
    { ISO-10646-UCS-4 csUCS4 }
    { DEC-MCS dec csDECMCS }
    { hp-roman8 roman8 r8 csHPRoman8 }
    { macintosh mac csMacintosh }
    { IBM037 cp037 ebcdic-cp-us ebcdic-cp-ca ebcdic-cp-wt ebcdic-cp-nl
      csIBM037 }
    { IBM038 EBCDIC-INT cp038 csIBM038 }
    { IBM273 CP273 csIBM273 }
    { IBM274 EBCDIC-BE CP274 csIBM274 }
    { IBM275 EBCDIC-BR cp275 csIBM275 }
    { IBM277 EBCDIC-CP-DK EBCDIC-CP-NO csIBM277 }
    { IBM278 CP278 ebcdic-cp-fi ebcdic-cp-se csIBM278 }
    { IBM280 CP280 ebcdic-cp-it csIBM280 }
    { IBM281 EBCDIC-JP-E cp281 csIBM281 }
    { IBM284 CP284 ebcdic-cp-es csIBM284 }
    { IBM285 CP285 ebcdic-cp-gb csIBM285 }
    { IBM290 cp290 EBCDIC-JP-kana csIBM290 }
    { IBM297 cp297 ebcdic-cp-fr csIBM297 }
    { IBM420 cp420 ebcdic-cp-ar1 csIBM420 }
    { IBM423 cp423 ebcdic-cp-gr csIBM423 }
    { IBM424 cp424 ebcdic-cp-he csIBM424 }
    { IBM437 cp437 437 csPC8CodePage437 }
    { IBM500 CP500 ebcdic-cp-be ebcdic-cp-ch csIBM500 }
    { IBM775 cp775 csPC775Baltic }
    { IBM850 cp850 850 csPC850Multilingual }
    { IBM851 cp851 851 csIBM851 }
    { IBM852 cp852 852 csPCp852 }
    { IBM855 cp855 855 csIBM855 }
    { IBM857 cp857 857 csIBM857 }
    { IBM860 cp860 860 csIBM860 }
    { IBM861 cp861 861 cp-is csIBM861 }
    { IBM862 cp862 862 csPC862LatinHebrew }
    { IBM863 cp863 863 csIBM863 }
    { IBM864 cp864 csIBM864 }
    { IBM865 cp865 865 csIBM865 }
    { IBM866 cp866 866 csIBM866 }
    { IBM868 CP868 cp-ar csIBM868 }
    { IBM869 cp869 869 cp-gr csIBM869 }
    { IBM870 CP870 ebcdic-cp-roece ebcdic-cp-yu csIBM870 }
    { IBM871 CP871 ebcdic-cp-is csIBM871 }
    { IBM880 cp880 EBCDIC-Cyrillic csIBM880 }
    { IBM891 cp891 csIBM891 }
    { IBM903 cp903 csIBM903 }
    { IBM904 cp904 904 csIBBM904 }
    { IBM905 CP905 ebcdic-cp-tr csIBM905 }
    { IBM918 CP918 ebcdic-cp-ar2 csIBM918 }
    { IBM1026 CP1026 csIBM1026 }
    { EBCDIC-AT-DE csIBMEBCDICATDE }
    { EBCDIC-AT-DE-A csEBCDICATDEA }
    { EBCDIC-CA-FR csEBCDICCAFR }
    { EBCDIC-DK-NO csEBCDICDKNO }
    { EBCDIC-DK-NO-A csEBCDICDKNOA }
    { EBCDIC-FI-SE csEBCDICFISE }
    { EBCDIC-FI-SE-A csEBCDICFISEA }
    { EBCDIC-FR csEBCDICFR }
    { EBCDIC-IT csEBCDICIT }
    { EBCDIC-PT csEBCDICPT }
    { EBCDIC-ES csEBCDICES }
    { EBCDIC-ES-A csEBCDICESA }
    { EBCDIC-ES-S csEBCDICESS }
    { EBCDIC-UK csEBCDICUK }
    { EBCDIC-US csEBCDICUS }
    { UNKNOWN-8BIT csUnknown8BiT }
    { MNEMONIC csMnemonic }
    { MNEM csMnem }
    { VISCII csVISCII }
    { VIQR csVIQR }
    { KOI8-R csKOI8R }
    { IBM00858 CCSID00858 CP00858 PC-Multilingual-850+euro }
    { IBM00924 CCSID00924 CP00924 ebcdic-Latin9--euro }
    { IBM01140 CCSID01140 CP01140 ebcdic-us-37+euro }
    { IBM01141 CCSID01141 CP01141 ebcdic-de-273+euro }
    { IBM01142 CCSID01142 CP01142 ebcdic-dk-277+euro ebcdic-no-277+euro }
    { IBM01143 CCSID01143 CP01143 ebcdic-fi-278+euro ebcdic-se-278+euro }
    { IBM01144 CCSID01144 CP01144 ebcdic-it-280+euro }
    { IBM01145 CCSID01145 CP01145 ebcdic-es-284+euro }
    { IBM01146 CCSID01146 CP01146 ebcdic-gb-285+euro }
    { IBM01147 CCSID01147 CP01147 ebcdic-fr-297+euro }
    { IBM01148 CCSID01148 CP01148 ebcdic-international-500+euro }
    { IBM01149 CCSID01149 CP01149 ebcdic-is-871+euro }
    { IBM1047 IBM-1047 }
    { PTCP154 csPTCP154 PT154 CP154 Cyrillic-Asian }
    { Amiga-1251 Ami1251 Amiga1251 Ami-1251 }
    { UNICODE-1-1 csUnicode11 }
    { CESU-8 csCESU-8 }
    { BOCU-1 csBOCU-1 }
    { UNICODE-1-1-UTF-7 csUnicode11UTF7 }
    { ISO-8859-14 iso-ir-199 ISO_8859-14:1998 ISO_8859-14 latin8 iso-celtic
      l8 }
    { ISO-8859-15 ISO_8859-15 Latin-9 }
    { ISO-8859-16 iso-ir-226 ISO_8859-16:2001 ISO_8859-16 latin10 l10 }
    { GBK CP936 MS936 windows-936 }
    { JIS_Encoding csJISEncoding }
    { Shift_JIS MS_Kanji csShiftJIS }
    { Extended_UNIX_Code_Packed_Format_for_Japanese csEUCPkdFmtJapanese
      EUC-JP }
    { Extended_UNIX_Code_Fixed_Width_for_Japanese csEUCFixWidJapanese }
    { ISO-10646-UCS-Basic csUnicodeASCII }
    { ISO-10646-Unicode-Latin1 csUnicodeLatin1 ISO-10646 }
    { ISO-Unicode-IBM-1261 csUnicodeIBM1261 }
    { ISO-Unicode-IBM-1268 csUnicodeIBM1268 }
    { ISO-Unicode-IBM-1276 csUnicodeIBM1276 }
    { ISO-Unicode-IBM-1264 csUnicodeIBM1264 }
    { ISO-Unicode-IBM-1265 csUnicodeIBM1265 }
    { ISO-8859-1-Windows-3.0-Latin-1 csWindows30Latin1 }
    { ISO-8859-1-Windows-3.1-Latin-1 csWindows31Latin1 }
    { ISO-8859-2-Windows-Latin-2 csWindows31Latin2 }
    { ISO-8859-9-Windows-Latin-5 csWindows31Latin5 }
    { Adobe-Standard-Encoding csAdobeStandardEncoding }
    { Ventura-US csVenturaUS }
    { Ventura-International csVenturaInternational }
    { PC8-Danish-Norwegian csPC8DanishNorwegian }
    { PC8-Turkish csPC8Turkish }
    { IBM-Symbols csIBMSymbols }
    { IBM-Thai csIBMThai }
    { HP-Legal csHPLegal }
    { HP-Pi-font csHPPiFont }
    { HP-Math8 csHPMath8 }
    { Adobe-Symbol-Encoding csHPPSMath }
    { HP-DeskTop csHPDesktop }
    { Ventura-Math csVenturaMath }
    { Microsoft-Publishing csMicrosoftPublishing }
    { Windows-31J csWindows31J }
    { GB2312 csGB2312 }
    { Big5 csBig5 }
}

proc tcl_encoding {enc} {
    global encoding_aliases
    set names [encoding names]
    set lcnames [string tolower $names]
    set enc [string tolower $enc]
    set i [lsearch -exact $lcnames $enc]
    if {$i < 0} {
	# look for "isonnn" instead of "iso-nnn" or "iso_nnn"
	if {[regsub {^iso[-_]} $enc iso encx]} {
	    set i [lsearch -exact $lcnames $encx]
	}
    }
    if {$i < 0} {
	foreach l $encoding_aliases {
	    set ll [string tolower $l]
	    if {[lsearch -exact $ll $enc] < 0} continue
	    # look through the aliases for one that tcl knows about
	    foreach e $ll {
		set i [lsearch -exact $lcnames $e]
		if {$i < 0} {
		    if {[regsub {^iso[-_]} $e iso ex]} {
			set i [lsearch -exact $lcnames $ex]
		    }
		}
		if {$i >= 0} break
	    }
	    break
	}
    }
    if {$i >= 0} {
	return [lindex $names $i]
    }
    return {}
}

proc faketsv {} {
    namespace eval tsv {
	proc exists {a b} {
	    global $a
	    return [info exists $a\($b\)]
	}
	proc get {a b} {
	    global $a
	    return [::set $a\($b\)]
	}
	proc set {a b v} {
	    global $a
	    return [::set $a\($b\) $v]
	}
	proc unset {a {b {}}} {
	    global $a
	    if {$b eq {}} {
		::unset $a
	    } else {
		::unset $a\($b\)
	    }
	}
	proc array args {
	    global [::lindex $args 1]
	    return [eval ::array $args]
	}
	proc llength {a b} {
	    global $a
	    return [::llength [::set $a\($b\)]]
	}
	proc lindex {a b i} {
	    global $a
	    return [::lindex [::set $a\($b\)] $i]
	}
	proc lpush {a b v pos} {
	    global $a
	    if {![info exists $a\($b\)]} {
		::set $a\($b\) [list $v]
	    } elseif {$pos eq "end"} {
		::lappend $a\($b\) $v
	    } else {
		::set $a\($b\) [::linsert [::set $a\($b\)] $pos $v]
	    }
	}
	proc lpop {a b i} {
	    global $a
	    ::set v [::set $a\($b\)]
	    ::set x [::lindex $v $i]
	    ::set $a\($b\) [::lreplace $v $i $i]
	    return $x
	}
	proc linsert args {
	    ::set a [::lindex $args 0]
	    ::set b [::lindex $args 1]
	    global $a
	    if {![info exists $a\($b\)]} {
		::set $a\($b\) [::lrange $args 3 end]
	    } else {
		::set $a\($b\) [eval ::linsert \$$a\($b\) \
				    [::lrange $args 2 end]]
	    }
	}
	proc lsearch args {
	    ::set a [::lindex $args 0]
	    ::set b [::lindex $args 1]
	    global $a
	    ::set flags {}
	    ::set args [::lrange $args 2 end]
	    ::set arg [::lindex $args 0]
	    if {[string match "-*" $arg]} {
		::set args [::lrange $args 1 end]
		::lappend flags $arg
	    }
	    return [eval ::lsearch $flags \$$a\($b\) $args]
	}
	proc lappend {a b v} {
	    global $a
	    return [::lappend $a\($b\) $v]
	}
    }
}

# initializers
set nullid "0000000000000000000000000000000000000000"

set history {}
set historyindex 0
set fh_serial 0
set nhl_names {}
set highlight_paths {}
set searchdirn -forwards
set boldrows {}
set boldnamerows {}

set stopped 0
set stuffsaved 0
set patchnum 0
set lookingforhead 0
set localrow -1
set lserial 0

# defaults...
set datemode 0
set diffopts "-U 5 -p"
set wrcomcmd "git diff-tree --stdin -p --pretty"

set gitencoding {}
catch {
    set gitencoding [exec git repo-config --get i18n.commitencoding]
}
if {$gitencoding == ""} {
    set gitencoding "utf-8"
}
set tclencoding [tcl_encoding $gitencoding]
if {$tclencoding == {}} {
    puts stderr "Warning: encoding $gitencoding is not supported by Tcl/Tk"
}

set mainfont {Helvetica 9}
set textfont {Courier 9}
set uifont {Helvetica 9 bold}
set findmergefiles 0
set maxgraphpct 50
set revlistorder 0
set fastdate 0
set maxwidth 16
set uparrowlen 7
set downarrowlen 7
set mingaplen 30
set cmitmode "patch"
set wrapcomment "none"
set showneartags 1
set showlocalchanges 1
set maxrefs 20
set maxlinelen 200

set colors {green red blue magenta darkgrey brown orange}
set bgcolor white
set fgcolor black
set diffcolors {red "#00a000" blue}

catch {source ~/.gitk}

font create optionfont -family sans-serif -size -12
setcoords

# parse command-line arguments
set nothread 0
set revtreeargs {}
foreach arg $argv {
    switch -- $arg {
	"" { }
	"-d" { set datemode 1 }
	"--nothread" { set nothread 1 }
	default {
	    lappend revtreeargs $arg
	}
    }
}

# check that we can find a .git directory somewhere...
set gitdir [gitdir]
if {![file isdirectory $gitdir]} {
    show_error {} . "Cannot find the git directory \"$gitdir\"."
    exit 1
}

set cmdline_files {}
set i [lsearch -exact $revtreeargs "--"]
if {$i >= 0} {
    set cmdline_files [lrange $revtreeargs [expr {$i + 1}] end]
    set revtreeargs [lrange $revtreeargs 0 [expr {$i - 1}]]
} elseif {$revtreeargs ne {}} {
    if {[catch {
	set f [eval exec git rev-parse --no-revs --no-flags $revtreeargs]
	set cmdline_files [split $f "\n"]
	set n [llength $cmdline_files]
	set revtreeargs [lrange $revtreeargs 0 end-$n]
    } err]} {
	# unfortunately we get both stdout and stderr in $err,
	# so look for "fatal:".
	set i [string first "fatal:" $err]
	if {$i > 0} {
	    set err [string range $err [expr {$i + 6}] end]
	}
	show_error {} . "Bad arguments to gitk:\n$err"
	exit 1
    }
}

if {!$nothread} {
    if {[catch {package require Thread}]} {
	set nothread 1
    }
}

if {$nothread} {
    faketsv

    proc do_main args {
	eval run $args
    }

    proc do_layout args {
	eval $args
    }

    proc do_allcomm args {
	eval $args
    }

    proc preproc {str map} {
	set str [regsub -all {%tsvexists% *([a-z0-9_$]*) +([a-z0-9_$]*)} \
		     $str {info exists \1\\(\2\\)}]
	set str [regsub -all {%tsv[gs]et% *([a-z0-9_$]*) +([a-z0-9_$]*)} \
		     $str {set \1\\(\2\\)}]
	set str [regsub -all {%tsvsearch% *([a-z0-9_$]*) +([a-z0-9_$]*)} \
		     $str {lsearch -exact [set \1\\(\2\\)]}]
	set str [regsub -all {%tsvllength% *([a-z0-9_$]*) +([a-z0-9_$]*)} \
		     $str {llength [set \1\\(\2\\)]}]
	set str [regsub -all {%tsvlindex% *([a-z0-9_$]*) +([a-z0-9_$]*)} \
		     $str {lindex [set \1\\(\2\\)]}]
	set str [regsub -all {%tsvappend% *([a-z0-9_$]*) +([a-z0-9_$]*)} \
		     $str {lappend \1\\(\2\\)}]
	return [string map $map $str]
    }

    eval $mnotthreadstuff

    set map {%iflthread% \# %ifnotlthread% {}
	%ifmthread% \# %ifnotmthread% {}
	%ifathread% \#
	%ifnotthread% {}}

    eval [preproc $lthreadstuff $map]
    eval [preproc $commonstuff $map]
    eval [preproc $athreadstuff $map]
    eval [preproc $mstuff $map]

} else {
    set allthreadstuff {
	proc gset {var val} {
	    global $var
	    set $var $val
	}

	proc do_main args {
	    global mainthread
	    thread::send -async $mainthread $args
	}
    }

    proc do_layout args {
	global layoutthread

	thread::send -async $layoutthread $args
    }

    proc do_allcomm args {
	global allcommthread

	thread::send -async $allcommthread $args
    }

    proc preproc {str map} {
	set str [regsub -all {%tsvsearch% *([a-z0-9_$]*) +([a-z0-9_$]*)} \
		     $str {tsv::lsearch \1 \2 -exact}]
	set str [regsub -all -line {%tsvappend%(.*)$} \
		     $str {tsv::lpush \1 end}]
	set str [regsub -all {%tsv([a-z]*)%} $str {tsv::\1}]
	return [string map $map $str]
    }

    eval $mthreadstuff

    set map_l {%iflthread% {} %ifnotlthread% \#
	%ifmthread% \# %ifnotmthread% {}
	%ifathread% \# %ifnotthread% \#}
    set map_m {%iflthread% \# %ifnotlthread% {}
	%ifmthread% {} %ifnotmthread% \#
	%ifathread% \# %ifnotthread% \#}
    set map_a {%iflthread% \# %ifnotlthread% {}
	%ifmthread% \# %ifnotmthread% {}
	%ifathread% {} %ifnotthread% \#}

    set layoutthread [thread::create]
    do_layout eval [preproc $commonstuff $map_l]
    do_layout eval [preproc $lthreadstuff $map_l]
    do_layout eval $allthreadstuff
    do_layout gset mainthread [thread::id]
    foreach v {datemode tclencoding} {
	do_layout gset $v [set $v]
    }

    eval [preproc $commonstuff $map_m]
    eval [preproc $mstuff $map_m]

    set allcommthread [thread::create]
    do_allcomm eval [preproc $commonstuff $map_a]
    do_allcomm eval [preproc $athreadstuff $map_a]
    do_allcomm eval $allthreadstuff
    do_allcomm gset mainthread [thread::id]
}

tsv::set options maxwidth $maxwidth
tsv::set options uparrowlen $uparrowlen
tsv::set options downarrowlen $downarrowlen
tsv::set options mingaplen $mingaplen
tsv::set options showlocalchanges $showlocalchanges

makewindow

set nextviewnum 1
set curview 0
set selectedview 0
set selectedhlview None
tsv::set viewfiles 0 {}
set viewperm(0) 0
tsv::set viewargs 0 {}

if {$cmdline_files ne {} || $revtreeargs ne {}} {
    # create a view for the files/dirs specified on the command line
    set curview 1
    set selectedview 1
    set nextviewnum 2
    tsv::set viewname 1 "Command line"
    tsv::set viewfiles 1 $cmdline_files
    tsv::set viewargs 1 $revtreeargs
    set viewperm(1) 0
    addviewmenu 1
    .bar.view entryconf Edit* -state normal
    .bar.view entryconf Delete* -state normal
}

if {[info exists permviews]} {
    foreach v $permviews {
	set n $nextviewnum
	incr nextviewnum
	tsv::set viewname $n [lindex $v 0]
	tsv::set viewfiles $n [lindex $v 1]
	tsv::set viewargs $n [lindex $v 2]
	set viewperm($n) 1
	addviewmenu $n
    }
}
readrefs
getcommits $curview
